# JavaScript新特性
## 准备工作
####  安装node和nodemon 
#### 12.16.3版本的node已经逐渐支持es2015以上的新特性
##### nodemon的作用是监听文件代码的变动,自动重启
##### 下载方式 cnpm i -g nodemon
## let,const和var的区别
![image](D73EA6E006584F0785348448336FD73F)
## let 与块级作用域
##### 作用域:顾名思义,只代码中的某一个成员起作用的范围.
##### 在ES6以前只有两种作用域,分别是全局作用域和函数作用域,在ES2015里又新增了一个块级作用域."块"指的是代码中用一对花括号"{}"所包裹起来的范围
```
<!--例如if语句和循环语句-->
if(true){
    console.log('这里是块级作用域')
}
for(var i = 0 ; i < 10 ; i++){
    console.log(i,'这里是块级作用域')
}
```
##### 在以前“块”是没有单独的定义的，这就导致我们在块中定义的成员外部也可以访问到

```
<!--例如-->
if(true){
    var a = 123;
}
console.log(a); //==>打印出123
```
这一点对于复杂代码是非常不利的，也是不安全的

#### let就是拥有块级作用域的声明变量，通过let声明的变量只能在所声明的代码块中被访问到

```
<!--例如-->
if(true){
    let a = 123;
}
console.log(a); //==>打印出 a is not defind
<!--这说明块级作用域内的声明，在外部是无法使用的-->
```
#### 块级作用域的这种特性非常适用于for循环当中的计数器，传统循环如果出现循环嵌套的情况就必须为计数器设置不同的名称，否则就会出现问题

```
for(var i = 0 ; i < 3 ; i++){
     for(var i = 0 ; i < 3 ; i++){
        console.log(i)
    } 
    console.log('内层结束i=' + i)//当i=3时，不符合外部循环条件，循环停止
}
<!--输出结果0 1 2 内层结束i=3-->
<!--  A，B两个for循环的嵌套，他们声明的变量都是i，双层循环嵌套实际上应该3*3打印9次，但上面就打印了三次，原因是两次循环声明变量用的是var，所以他们的变量i不是不是块级成员，而是全局成员，那内层声明的i就会覆盖掉外层声明的i，那么内层拿到的是3，当i=3时，不符合外部循环条件i<3，循环停止  --> 

for(let i = 0 ; i < 3 ; i++){
	for(let i = 0 ; i < 3 ; i++){
		console.log(i)
	}
	console.log('内存循环输出i=' + i)
}
<!--输出结果： 0 1 2 内存循环输出i=0 0 1 2 内存循环输出i=1 0 1 2 内存循环输出i=2-->
let就不会有这问题，let所声明的变量只会在当前循环的代码块中生效，i只是当前块级作用域的局部变量，不会影响到外层的变量
```
##### 除此之外还有一个典型的应用场景---就是我们循环的去注册事件时，在事件的处理函数中访问循环的计数器，这种情况下就会出现一些问题

```
var elements = [{},{},{}];//每一个空对象都代表一个元素
for(var i = 0 ; i < elements.length ; i++){
	elements[i].onclick=function(){
		console.log(i)
	}
}
elements[0].onclick();//3
elements[1].onclick();//3
elements[2].onclick();//3
<!--这里打印的i实际上是全局作用域的i，当指向函数的时候实际上循环已经执行过后i已经累加到了3，所以不管你打印那个i最后的结果都是3-->
<!--实际上这也是一个闭包的应用场景，我们通过使用闭包也可以解决这类问题-->



var elements = [{},{},{}];//每一个空对象都代表一个元素
for(var i = 0 ; i < elements.length ; i++){
	elements[i].onclick = (function(i){
		return function(){
			console.log(i)
		}
	})(i)
}
elements[0].onclick();//0
elements[1].onclick();//1
elements[2].onclick();//2
<!--闭包通过借助函数作用域来拜托全局作用域的影响-->
在块级作用域就不用这么麻烦了，我们把声明计数器的var改成let，使我们的i只能在块级作用域内被访问，这样问题自然就解决了，其实这个内部也是一种闭包的机制，在onclick执行的时候循环已经结束了，这时i已经销毁了，只有执行闭包机制我们才能获得这个i


```
#### for循环的特别之处--for循环内部有两层作用域

```
for(let i = 0 ; i < 3 ; i++){
    let i = 'foo';
}
<!--输出结果：foo foo foo-->
let i = 0 ;//外部循环的局部变量
for(i = 0 ; i < 3 ; i++){
    let i = 'foo';//块级作用域内部的局部变量
}
```
### let 和 var 的区别
let 不会出现声明变量提升的情况
var 会出现声明变量提升的情况
```
console.log(a);//值为underfined，这里的现象叫变量声明的提升
var a = 1；
------------
```

```
console.log(a);//报错：在初始化之前不能访问'a'
let a = 1；

```
#### 为啥不对var升级？
直接升级var会导致很多原有的工作出现问题，所以出现了let


## const 恒量/常量
const可以声明恒量和常量，在let基础上多了一个只读特性，变量一旦声明之后就不能够被修改。

```
<!--1.const在声明后不能再次被赋值-->
const a = 1;
a = 2;
// TypeError: Assignment to constant variable.类型错误:赋值给常量变量。
<!--2.const声明时必须设置初始值，声明和赋值不能像var一样，放到两个语句当中-->
const a ;
a = 1;
// SyntaxError: Missing initializer in const declaration.在const声明中缺少初始化器
```
#### const声明的成员不允许被修改，只是说不允许声明过后重新指向一个新的内存地址，并不是说不允许修改恒量中的属性成员

```
const obj = {};
obj.name = 'hh';
<!--这种情况并没有修改obj所指向的内存地址，只是修改了这块内存空间当中的数据，所以说是被允许的-->
<!--那么相反如果我们把obj指向一个新的空对象此时就会报错,因为这种赋值会改变obj的内存指向-->
obj = {};
// TypeError: Assignment to constant variable.类型错误:赋值给常量变量。
```
++**==最佳实践：不用var，主用const，配合let==**++
因为var有很多陋习，如先使用变量再去声明变量，主要使用const能让我们更明确代码中声明的变量会不会被修改

## 数组的解构

```
// 数组的结构
const arr = [100,200,300];
// 以前获取数组中指定的元素需要通过索引获取对应的值.如下:
const a = arr[0];
const b = arr[1];
const c = arr[2];
console.log(a,b,c);//100 200 300
```
```
// 现在通过解构的方式去快速提取数组中指定的成员
const arr = [100,200,300];
const [a,b,c] = arr;//以前设置变量名的地方放一个[],然后在[]里面是从数组中提取出来的数据所存放的变量a,b,c，那内部按照变量名出现的位置分配数组中所对应的位置的数组
console.log(a,b,c);//100 200 300
```
```
// 如果想获取第三个成员
const arr = [100,200,300];
const [,,c] = arr;//就把前两个变量去掉，保留逗号，确保解构的格式与数组是一致的
console.log(c);//300
```

```
const arr = [100,200,300];
const [a,...d] = arr;//三个点表示提取从当前位置往后的所有成员
console.log(d);//[ 200, 300 ]
// 需要注意的是，这种三个点的用法只能在解构的最后一个位置使用
```

```
// 解构位置的成员少于数组长度，就会从前到后的顺序去提取，后面的多出来的成员就不会被提取
const arr = [100,200,300];
const [a] = arr;
console.log(a);//100
```

```
//相反呢，解构位置的成员大于数组的长度，多余的成员会返回undefined
const arr = [100,200,300];
const [a,b,c,d] = arr;
console.log(a,b,c,d);//100 200 300 undefined
```

```
//给解构成员设置默认值，在解构位置变量后面跟上=并附上默认值，那么当我们没有提取到数组当中对应的成员，那么这里就会得到默认值
const arr = [100,,300];
const [a,b='bbb',c,d='ddd'] = arr;
console.log(a,b,c,d);//100 bbb 300 ddd
```

```
// 实例：截取字符串中的某一个值
// 以前的做法
const str = '/a/b/c';
const arr = str.split('/');
const a = arr[1];
console.log(a);//a
// 现在的做法
const [,rabt] = arr;
console.log(rabt);//a
```
## 对象的解构
对象的解构是需要根据属性名去匹配提取的为不是位置

```
// 解构对象
const obj = {name:'hcb',age:'25'};
const { name , age } = obj;//在花括号里同样是提取出来的数据所存放的变量名，不过变量名有一个很重要的作用，那就是去匹配所对应的成员，从而去提取指定成员的值
console.log(name,age);//hcb 25
```

```
const obj = {name:'hcb',age:'25'};
const { age } = obj;//age就是提取了obj对象age属性的值
console.log(age);//25
```
解构对象的其他特点基本上是和解构数组完全一致的，例如没有匹配到的成员返回underfined，可以设置默认值等。
解构中的特殊情况：解构中的变量名是用来匹配被解构对象中的属性名的，当当前的作用域当中有同名的变量名就会产生冲突

```
const obj = {name:'hcb',age:25};
const age = 27;
const { age } = obj;//因为obj里的age属性必须通过age去提取，所以这里必须使用age去提取，这样的话这一冲突就不可避免
console.log(age);
// SyntaxError: Identifier 'age' has already been declared
// SyntaxError:标识符'age'已经被声明
```

```
//使用重命名的方式解决变量名冲突的问题
const obj = {name:'hcb',age:25};
const age = 27;
const { age:objAge } = obj;
console.log(objAge);//25
```
```
//在重命名后需要使用默认值
const obj = {name:'hcb'};
const age = 27;
const { age:objAge = 26} = obj;
console.log(objAge);//26
```

```
//解构对象的更多用法
const { log } = console;
log(1);//
log('abb');//abb
//这样一来简化了代码的编写，整体的体积也会减小很多
```

## 模板字符串字面量
模板字符串需要用反引号``去标识

```
//如果在字符串当中需要使用反引号可以使用\转义
const str = `this is a \`apple\``;
console.log(str);//this is a apple
```
### 新特性
#### 传统的字符串并不支持换行,模板字符串支持多行字符串,对于输出HTML字符串非常方便

```
const str = `<div>
    <p>this is a apple</p>
</div>
`;
console.log(str)
<div>
    <p>this is a apple</p>
</div>
```

#### 模板字符串还支持通过插值表达式 的方式在字符串中嵌入所对应的数值

```
const thing = 'apple';
const str = `this is a ${thing}`;
console.log(str);//this is a apple

```
##### 这里的${}是标准的JavaScript,这里不仅可以嵌入变量,还可以嵌入任何标准的js语句,这个表达式返回的结果最终会输出在字符串当中插值表达式的位置

```
const str = `这是${1 + 1 }个苹果`;
console.log(str);这是2个苹果
```
## 模板字符串标签函数--模板字符串的高级用法
在定义模板字符串之前添加一个标签,这个标签实际上就是一个特殊的函数,添加这标签就是调用这个函数
```
const str = console.log`abc`;//[ 'abc' ]
//为啥用console.log会打印一个数组呢?
```

```
//尝试定义一个标签函数
先定义一个标签和变量,然后定义一个使用标签函数的模板字符串,使用这个函数之前要先定义这个函数
const name = 'hcb';
const gender = true;
function myTagFunc(strings){//函数接受数组参数
	console.log(strings);//[ '', ' is a ', '' ]
	//打印出来发现,这个数组的内容就是模板字符串内容分割过后的结果
	//因为这个模板字符串中可能会有表达式,这里的数组就是按照表达式分割过后 
	//那些静态的内容,所以是一个数组
}
const result = myTagFunc`${name} is a ${gender}`;

```

```
//除了数组以外,这个函数还可以接收到所有模板字符串当中表达式的返回值,如name和gender
const name = 'hcb';
const gender = true;
// function myTagFunc(strings,name,gender){//函数接受数组参数
// 	console.log(strings,name,gender);//[ '', ' is a ', '' ] 'hcb' true
// }
//等同于
function myTagFunc(strings,...values){//函数接受数组参数
	console.log(strings,...values);//[ '', ' is a ', '' ] 'hcb' true
}
const result = myTagFunc`${name} is a ${gender}`;

```

```
//那么这个 函数的返回值就是带标签的模板字符串所对应的返回值
const name = 'hcb';
const gender = true;
function myTagFunc(strings){//函数接受数组参数
	const sex = gender?'boy':'girl';
	return name + strings[1] + sex;
}
const result = myTagFunc`${name} is a ${gender}`;
console.log(result);//hcb is a boy
```
标签函数的作用实际上就是我们对模板字符串的加工.我们可以利用标签函数这一特性去实现模板的多语言化,比如翻译成中文或英文,或者是检查我们的模板字符串当中是否存在一些不安全的字符的需求,甚至可以使用这种特性来去实现小型的模板引擎
## 字符串的扩展方法
#### 常用方法 返回值为true或false
- includes('某某') 判断字符串当中是否包含某某
- startsWith('某某') 判断字符串是不是某某开头
- endsWith('某某') 判断字符串是不是某某结尾

---
以上这些方法可以更方便的判断字符串中是否包含指定的内容，相比于indexOf和正则表达式查找会便捷很多！

注意：以上方法严格区分大小写！

```
const message = `Where are you going?`;
console.log(
message.includes('you'),
message.startsWith('Where'),
message.startsWith('where'),
message.endsWith('?')
)；//true true false true

```
## 函数的扩展
### 参数默认值
es2015当中为函数的形态列表扩展了一些特别有用新的语法
1. 参数的默认值
    
```
//函数参数的默认值--传统写法
function foo(enable){
	// 以前想要为函数的参数去定义默认值，我们需要在函数体中通过逻辑代码来实现，例如foo函数的参数enable，我们需要是enable的默认值是true，那么我们需要通过逻辑判断来决定是否使用默认值。
	// enable = enable || true;//短路运算法
	// 在这里你会发现人们经常会犯错的地方，因为很多人喜欢用短路运算的方式设置默认值，在这个函数的情况下是不能通过短路运算的方式设置默认值，因为这样会导致如果我们传入false的时候也会 使用默认值，那这事很明显的错误，正确做法是判断enable是否等于undefined，然后使用默认值
	enable = enable === undefined ? true : enable;
	console.log('foo invoked - enable')
	console.log(enable)
}
foo(false);
```

```
//es2015函数的参数默认值
//函数参数的默认值--es2015写法
function foo(enable = true){//这里传递的默认值会在我们没有传递实参或undefined的时候使用
	
	console.log('foo invoked - enable')
	console.log(enable)
}
foo(false);

```
需要注意的是，当有多个参数的时候，带有默认值的形参一定要出现在参数列表的最后，因为我们的参数是按照次序传递的，如果带有默认值的参数不放在最后的话，那我们的默认值将无法工作
```
//多个默认值的错误写法
function foo(enable = true,name){
	
	console.log('foo invoked - enable')
	console.log(enable,name)
}
foo('hcb');
```

```
//多个参数的正确写法，带有默认值的参数放在最后
function foo(name,enable = true){
	
	console.log('foo invoked - enable')
	console.log(name,enable)
}
foo('hcb');
```
### 剩余参数 ...
在ECMAscript中很多方法都可以传递任意个数的参数如console.log()方法,
对于未知的参数,以前使用arguments对象去接收,arguments实际上是一个伪数组,在es2015新增了...操作符,这种操作符有两个作用
- rest作用:剩余操作符

```
//对于未知参数使用arguments对象接收
function foo(){
	console.log(arguments)
}
// arguments对象实际上是一个伪数组;
foo(1,2,3,4);//{ '0': 1, '1': 2, '2': 3, '3': 4 }
```


```
//...操作符,rest作用
//...操作符接收当前位置开始往后多有的实参,只能用一次,只能出现在形参的最后一位
function foo(str,...args){
	console.log(args)
}
// ...操作符意数组的形式返回函数传递的参数
foo('数数',1,2,3,4);//数数 [ 1, 2, 3, 4 ]
```
### 展开数组 ...
- ...操作符除了收齐剩余数据的用法还有种spread(展开)用法,展开操作符的用途很多先来了解一下与函数相关的数组参数展开

```
const arr = ['foo','bar','baz'];
//想把数组中的每个成员按照次序传递给console.log方法
console.log(
arr[0],
arr[1],
arr[2]
);//foo bar baz
//如果数组中的元素个数是不固定的,那一个个传的方式就行不通了
//以前使用函数方法的apply方法去调用函数,因为这种方法可以以数组的形式接收我们的实参列表
console.log.apply(console,arr);//foo bar baz
//apply的第一个参数时this指向,因为log方法是console调用的,这里指向的是console对象的本身,第二个参数是我们需要传递的实参列表这样一个数组
// es2015方法通过...的方法展开数组,大大简化了操作
console.log(...arr);//foo bar baz
```

## 箭头函数
es2015简化了函数表达式的定义方式

```
//传统的定义方式
function inc(number){
	return number + 1
}
const num = inc(1);
console.log(num)
```

```
//es2015定义函数的方式
const inc = n =>n+1;//这里使用的是编程中的连体字符Fira Code,简写,默认返回箭头后面的值
console.log(inc(100));//101
const inc2 = (n,m) => n + m;//多个参数
const inc3 = (n,m) =>{//多行代码需要自己手动写return
    if(n-m>0){
        console.log(`${n}>${m}`)
    }else{
        console.log(`${n}<=${m}`)
    }
    return n+m;
}
```

```
//使用箭头函数会让我们的代码更简短更易读
const arr = [ 1,2,3,4,5,6 ];
const filterArr = arr.filter(v => v%2);//过滤取余
console.log(filterArr);//[ 1, 3, 5 ]
```
## 箭头函数与this指向
相比于普通的函数,箭头函数还有一个重要的变化就是不会改变this的指向 

```

const person = {
	name:'tom',
	sayHi:function(){
		// 传统写法,this指向调用这个方法的对象
		console.log(`Hi,my name is ${this.name}`);//Hi,my name is tom
	},
	// es2015箭头函数当中没有this机制,不会改变this的指向,也就是说在我们箭头函数的外面this是什么,那么在里面拿到的就是什么
	sayHello:()=>{
		
		console.log(`Hello,my name is ${this.name}`);
		// 上面代码中，person.sayHello()方法是一个箭头函数，这是错误的。调用person.sayHello()时，如果是普通函数，该方法内部的this指向person；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致sayHello箭头函数定义时的作用域就是全局作用域。
	},
	sayHiAsync:function(){
		const _this = this;
		setTimeout(function(){//这个函数最终会被放在全局对象里面调用,所以this拿不到当前作用域里面的对象,拿到的是全局对象
			//因为是调用setTimeout函数的对象是window对象,所以name是undefined
			// 以前解决这种问题的方法就是定义一个_this来保存当前作用域的this
			
			console.log(`Hi,my name is ${_this.name}`);//Hi,my name is undefined
		},500)
		//es2015的做法是使用箭头函数不改变this的指向
		setTimeout(()=>{
			console.log(this.name);//tom
		},1000)
	}
};
person.sayHi();
person.sayHello();
person.sayHiAsync();
```
## 对象字面量的增强

```
const bar = 456
 const obj = {
	 foo:123,
	 // bar:bar,//传统写法
	 bar,//es6写法,同上等价
	 // method:function(){
		//  console.log('method',this.foo)
	 // },//传统写法
	 method(){
		 console.log('method',this.foo)
	 },//es6写法,同上等价,和普通的function函数的this的指向一样,内部的this指向当前对象
	 //另外对象最大的变化时可以使用表达式的返回值作为对象的属性名
	 //传统直接添加动态属性名会报错
	 // Math.random():789//SyntaxError: Unexpected token .
	 // es2015后可以直接[]添加动态属性名,这种属性名叫做计算属性名
	 [Math.random()]:789
 }
 // es5通过索引的方式添加属性名
 // obj[Math.random()] = 789;
 console.log(obj);//{ foo: 123,bar: 456,method: [Function: method],'0.988395699398273': 789 }
 obj.method();//method 123
```
## 对象的扩展方法
### Object.assign()方法:将多个源对象的属性复制到目标对象当中,如果对象中有相同的属性,源对象中的属性就会覆盖掉目标对象中的属性


```
const source1 = {
	a:123,
	b:456
}
const source2 = {
	b:147,
	d:555
}
const target = {
	a:456,
	c:789
}
const result = Object.assign(target,source1,source2);//相同属性后面的对象会覆盖前面的对象
console.log(target);//{ a: 123, c: 789, b: 147, d: 555 }

console.log(target === result);//true
```
复制对象的特性可以帮助我们在修改当前对象数据的时候不会修改对象内存地址的数据

```
function func(obj){
	// obj.name = 'hcb';//在函数中修改对象的属性值,那外界的对象也会发生变化,因为他们都指向同一个内存地址,也就是同一个数据
	const funcObj = Object.assign({},obj);//复制对象后就是一个全新的对象,修改的数据不会修改源对象的内存地址的数据
	funcObj.name = 'hcb';
	console.log(funcObj)
}
const obj = {name:'ddc'};
func(obj);//{ name: 'hcb' }
console.log(obj);//{ name: 'ddc' }
```

```
// 浅拷贝
const obj  = {a:{a:'ccc'},b:123};
const obj2 = Object.assign({},obj);
obj2.a.a = 'ddd';
console.log(obj);//{ a: { a: 'ddd' }, b: 123 }
//深拷贝
const nObj = {a:'hcb',b:24};
 const nObj2 = Object.assign({},nObj);
 nObj2.a = 'dg';
 console.log(nObj);//{ a: 'hcb', b: 24 }
```

[更多深拷贝浅拷贝内容](https://segmentfault.com/a/1190000018874254)



### Object.is方法:用来判断两个值是否相等

```
//传统判断数同值相等的方法
console.log(0 == false);//true,两等运算符会比较时自动转换数据类型
console.log(0 === false);//false,//三等会严格比较值和数据类型
console.log(-0 === +0);//true,严格等于不能区分-0和+0
console.log(NaN === NaN);//false,以前认为NaN是任意类型的值,所以严格等于的情况下是false
// es2015判断同值的方法
console.log(Object.is(-0,+0));//false,能判断-0和+0的不等
console.log(Object.is(NaN,NaN));//true,//现在认为NaN是一个特殊的值,所以相等
```
## Proxy(破乳阿 科c) 代理对象
如果我们想监视某个对象的读写,可以使用Object.defineProperty()方法来为我们的对象添加属性,这样就可以捕获到对象属性的读写过程,这种方法使用非常广泛,在vue3.0之前的版本就是使用Object.defineProperty()的方法实现的数据响应,从而完成双向数据绑定

---
在es2015又专门设置了一个Proxy类型,专门为对象设置访问代理器的,Proxy可以轻松监视到对象的读写过程,相比于Object.defineProperty(),Proxy更加强大,更加方便

---
下面看如何使用Proxy:

```
const person = {
	name:'hcb',
	age:24
}
// 创建Proxy代理对象,第一个参数:代理的目标对象,第二个参数:代理的处理对象
const ProxyPerson = new Proxy(person,{
	get(target,property){//监听代理对象调用属性名,第一个参数:代理的目标对象,第二个参数:外部访问时访问的属性名
	console.log(target,property);
	//正确的做法是先去判断代理对象是否存在这样一个属性,如果存在就返回值,如果不存在就返回undefined
	return property in target ? target[property] : undefined
	},
	set(target,property,value){//三个参数:代理目标对象,写入的属性名称,写入的属性值
		console.log(target,property,value);
		// 先进行校验
		if(property === 'age'){
			if(!Number.isInteger(value)){//当属性名是age时,判断一下值是否是int型,不是就报错
				throw new TypeError(`${value} is not an int`)
			}
		}
		//为代理目标设置属性名和属性值
		target[property] = value;
	}
})
// 通过代理对象为person写入一个真的属性
ProxyPerson.gender = true;
// ProxyPerson.age = '444';//set函数就会报错
ProxyPerson.age = 444;
console.log(ProxyPerson.name);//hcb
console.log(ProxyPerson.cc);//undefined
```
## Proxy vs Object.defineProperty()
- Proxy更加强大一些,defineProperty只能监视属性的读写,而Proxy能够监视到更多对象操作,如deleteProperty或对对象方法的调用等等

```
//delete对象操作监视
const person = {
	name:'hcb',
	age:27
}
const personProxy = new Proxy(person,{
	deleteProperty(target,property){
		// 代理对象删除属性的方法,参数:1.需要进行删除操作的目标对象;2.要删除的属性
		delete target[property]
	}
})
delete personProxy.age;
console.log(person);{ name: 'hcb' }
```
除了delete操作还有很多对象操作,如下:
![image](77944BA56DB0477A89613FC308C73C68)

- Proxy更好的支持数组对象的监视,defineProperty常见数组用法就是重写数组的操作方式指通过自定义的方式去覆盖掉数组的原型对象的push等方法,以此来劫持对应这个方法调用的过程

```
//如何用Proxy对象对数组进行监视
const list = [];
const listProxy = new Proxy(list,{
	set(target,property,value){//三个参数:目标对象,数组下标,设置的值
		console.log('set',property,value);
		target[property] = value;
		return true;//表示设置成功
	}
})
listProxy.push(10);//set 0 10.表示Proxy可以根据push操作推算出来当前添加的值所处的下标,并对整个目标数组进行调整设置
// listProxy.splice(0,0,9)
/**
 * set 1 10
 * set 0 9
 * set length 2
 * */
listProxy.splice(1,0,9)
/**
 * set 1 9
 * set length 2
 * */
console.log(list);//[ 10, 9 ]
```
- Proxy以非侵入的方式监管了对象的读写

也就是对一个已经定义的对象,Proxy不需要对象本身进行任何的操作就可以监视到对象的读写

```
const person = {
	name:'hcb',
	age:24
}
const personProxy = new Proxy(person,{
	get(target,property){
		return target[property]
	},
	set(target,property,value){
		target[property] = value;
	}
})
personProxy.name = 'tom';
console.log(personProxy.name)
```

而Object.definePropert需要用特定的方式单独去定义那些需要被监视的属性,对于一个已经存在的属性,需要做很多额外的操作

```
// Object.defineProperty以入侵的方式监管对象的读写
const person = {}
Object.defineProperty(person,'name',{
	get(){
		console.log('name 被访问')
		return person._name
	},
	set(value){
		console.log('name 被设置')
		person._name = value;
	}
})
Object.defineProperty(person,'age',{
	get(){
		console.log('age 被访问')
		return person._age
	},
	set(value){
		console.log('age 被设置')
		person._age = value;
	}
})

person.name = 'hcb';
console.log(person,person.name);//{ _name: 'hcb' } hcb
```

[更多内容](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler)
## Reflect (瑞弗莱 克t) 统一的对象操作API 
Reflect是es2015提供的一个全新的静态对象,是一个静态类,它不能通过 ~~new Reflect()~~ 的方法去构建一个实例对象,只能够调用静态类中的一些静态方法,和Math对象差不多.

Reflect内部封装了一系列对对象的底层操作,共13个,这13个方法的方法名与Proxy对象的Hander对象中的方法名是一致的,Reflect的成员方法其实就是对Proxy的处理对象的方法的默认实现,如get和set方法在不配置时,默认调用Reflect的get和set方法

```
const person = {
	name:'hcb',
	age:24
}
const personProxy = new Proxy(person,{})
// 相当于
const personProxy2 = new Proxy(person,{
	get(target,property){
		return Reflect.get(target,property)
	},
	set(target,property,value){
		Reflect.set(target,property,value)
	}
})
personProxy.name = 'tom';
console.log(personProxy.name,personProxy2.name)
```
Reflect的价值在于它统一提供了一套用于操作对象的API,体验更为合理

```
//按照传统方式-方法不统一
const obj = {
	name:'hcb',
	age:24,
	sex:'男'
}
console.log('name' in obj);//判断对象是否有这个属性名---操作符方式
console.log(delete obj['age']);//删除对象的这属性名--对象中的方法
console.log(Object.keys(obj));//获取当前对象的所有属性名
//es2015做法
const person = {
	name:'bg',
	age:27,
	sex:'男'
}
console.log(Reflect.has(person,'name'));//判断当前对象是否有这个属性
console.log(Reflect.deleteProperty(person,'age'));//删除当前对象的属性
console.log(Reflect.ownKeys(person));//获取当前对象的所有属性名
```
## Promise
Promise也是es2015提供的一个内置对象,提供了一种全新的异步解决方案,通过链式调用的方式解决了传统异步编程中回调函数嵌套过深的问题
## class 类
在此之前ECMAscript都是通过定义函数以及函数的原型对象实现的类型

```
function Person(name){
	 this.name = name;//通过this去访问当前的实例对象
 }
 // 在实例之间共享一些成员使用prototype
 Person.prototype.getName = function(){
	 console.log(`Hi,my name is ${this.name}`)
 }
 const p = new Person('hcb');
 p.getName();
```
自从es2015开始,我们就可以使用class关键词声明一个类型,这种独立定义类型的语法相比较之前函数的语法更容易理解,结构也更清晰一点

```
  // 1.定义Person类型
  class Person {
	  //2.在构造函数添加一些额外的逻辑,使用constructor构造函数方法
	  constructor(name){
		  this.name = name;//使用this访问当前的实例对象
	  }
	  //3.定义类的方法
	  say(){
		  console.log(`Hi,my name is ${this.name}`);
	  }
  }
  
  const p = new Person('hcb');
  p.say();
```
## 静态方法
在我们类型当中的方法一般分类实例方法和静态方法,实例方法需要通过这个类型构造的实例对象去调用,而静态方法则直接通过类型本身去调用

---
在es2015中新增添加静态成员的static关键词

```
  // 1.定义Person类型
  class Person {
	  //2.在构造函数添加一些额外的逻辑,使用constructor构造函数方法
	  constructor(name){
		  this.name = name;//使用this访问当前的实例对象
	  }
	  //3.定义类的方法
	  say(){
		  console.log(`Hi,my name is ${this.name}`);
	  }
	  //定义静态方法
	  static create(name){
		  return new Person(name)
	  }
  }
  
  const p = Person.create('hcb');
  p.say();
```

## 类的继承 extends

```
  // 1.定义Person类型
  class Person {
	  //2.在构造函数添加一些额外的逻辑,使用constructor构造函数方法
	  constructor(name){
		  this.name = name;//使用this访问当前的实例对象
	  }
	  //3.定义类的方法
	  say(){
		  console.log(`Hi,my name is ${this.name}`);
	  }
	  //定义静态方法--创建Person类型的实例
	  static create(name){
		  return new Person(name)
		  //需要注意的是,因为静态方法是挂载在类型上面的,所以静态方法内部的this不会指向实例对象,而是当前的类型
	  }
  }
  // 继承Person类
class PersonInfo extends Person {
	constructor(name,age){
		super(name);//继承父类的构造函数中的逻辑属性
		this.age = age;
	}
	say(){
		super.say();//继承父类的方法
		console.log(`My age is ${this.age}`);
	}
}
const info = new PersonInfo('tom',18);
info.say();
```

## Set数据结构
Set可以理解为一种集合,与传统的数组非常类似,不过Set的值是不能重复的,每个值在同一个Set当中都是唯一的,set是一个类型

```

const s = new Set();
s.add(1).add(2).add(3).add(4).add(2);//add方法添加值 由于Set.add()方法可以返回集合本身,可以链式调用,如果添加重复的值,那么重复的值会被忽略掉
console.log(s);//{ 1, 2, 3, 4 }
s.forEach((i)=>console.log(i));//遍历set集合
for (let i of s) {//遍历set集合
	console.log(i)
}
console.log(s.size);//Set的长度,相当于length
console.log(s.has(2));//判断set集合是否包含这个值,返回值是true或false
console.log(s.delete(4));//删除set集合中指定的值,删除成功返回true
s.clear();//清除set集合当中的全部内容
console.log(s);

```
set常见的应用方式是为数组进行去重

```
const arr = [1,2,3,4,5,1,5];
const result = new Set(arr);//数组去重
console.log(result);//Set { 1, 2, 3, 4, 5 }
const resultToArr = Array.from(result);//Set集合转数组
console.log(resultToArr);//[ 1, 2, 3, 4, 5 ]
```
## Map数据结构
Map的数据结构和对象有所类似,本质上都是键值对集合,但是对象的键只能是字符串类型,而Map的键可以是任意类型

```
const obj = {};
obj[true] = 'value';
obj[132] = 'value';
obj[{a:1}] = 'value';
console.log(Object.keys(obj));//[ '132', 'true', '[object Object]' ],所有键都被转换成了字符串
```
Map是严格意义上的键值对集合,用来去映射两个任意类型数据之间的对应关系

```
const m = new Map();//创建Map实例
const hcb = {name:'hcb'};
m.set(hcb,18);
m.set(123,456)
console.log(m);//Map { { name: 'hcb' } => 18 }
console.log(m.get(hcb));//获取指定键的值
console.log(m.has(hcb));//判断某个键是否存在
console.log(m.delete(hcb));//删除Map中指定的键值
m.clear();//清空所有键值
console.log(m)
// 遍历Map用forEach方法
m.forEach((value,key)=>{
	console.log(value,key)
})
```
Map与对象最大的区别就是可以用任意类型作为键,而对象只能使用字符串作为建
## Symbol
Symbol(符号)表示一个独一无二的值,主要用于解决对象属性值命名相同引起冲突的问题,Symbol目前最主要的作用就是为对象添加一个独一无二的属性标识符(属性名)


```
//Symbol是数据类型,独一无二,永远不会重复
const sym = Symbol();
console.log(typeof sym);//数据类型 symbol
console.log(Symbol() === Symbol());//false,Symbol永远是唯一的
//考虑到开发时的调试,Symbol允许我们添加一个字符串作为标识文本,这样对于多次使用Symbol的时候就可以在控制台区分出哪个是对应的Symbol
console.log(Symbol('abc'));//Symbol(abc)
console.log(Symbol('def'));//Symbol(def)
console.log(Symbol('ghi'));//Symbol(ghi)
```

es2015以前解决对象属性名冲突问题的方式是约定

```
// share.js
const cache = {}
// a.js
cache['a_foo'] = Math.random()
//b.js
cache['b_foo'] = 123
console.log(cache);//{ a_foo: 0.029474284031667963, b_foo: 123 }
```
es2015以后通过symbol解决对象属性名冲突的问题

```
// share.js
const cache = {}
// a.js
cache[Symbol('foo')] = Math.random()
//b.js
cache[Symbol('foo')] = 123
console.log(cache);//{ [Symbol(foo)]: 0.4502646589114949, [Symbol(foo)]: 123 }
```
es2015开始,对象可以使用Symbol作为属性名

```
const obj = {}
obj[Symbol()] = '123'
obj[Symbol()] = '456'
console.log(obj);//{ [Symbol()]: '123', [Symbol()]: '456' }因为Symbol都是独一无二的,不用担心冲突的问题
// 使用计算属性名的方式,直接在对象字面量中使用Symbol作为属性名
const obj2 = {
	[Symbol()]:'123'
}
console.log(obj2);//{ [Symbol()]: '123' }
```
借助这种特性去模拟实现对象的私有成员,
```
// 借助这种特性去模拟实现对象的私有成员,
// 所谓私有成员就是指程序内部可以访问,但外部无法直接访问的成员
const name = Symbol();
const person = {
	[name]:'hcb',
	sayName(){
		console.log(this[name]);
		return this[name];
	}
}
const myName = person.sayName();//hcb
console.log(myName);//hcb
```

## Symbol 补充
- Symbol的唯一性

```
//不管Symbol传入的值是否相同,Symbol都是不相等的
console.log(
	Symbol('foo') === Symbol('foo')
);//false
```
如果想在全局复用一个相同的Symbol值,可以使用全局变量的方式实现,或者使用Symbol类型提供的静态方法实现

```
//Symbol.for()方法可以接收一个字符串作为参数,相同的字符串就一定会返回相同的Symbol类型的值
// 这个方法内部维护了一个全局注册表,为我们的字符串和Symbol值提供了一个一一对应的关系
const s1 = Symbol.for('foo');
const s2 = Symbol.for('foo');
console.log(s1,s2,s1 === s2);//Symbol(foo) Symbol(foo) true
// 需要注意的是,在这个方法之中维护的是字符串和Symbol直接的对应关系,也就是说如果我们传入的不是字符串,那这个方法会把它转化成字符串,如下
console.log(
	Symbol.for(true) === Symbol.for('true')
);//true
```
- Symbol的属性

```
// 而且在Symbol当中提供了很多内置的Symbol常量属性,用来去作为内部方法的标识,这些标识符可以让自定义对象去实现js的内置接口
console.log(Symbol.iterator);//Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用。
console.log(Symbol.hasInstance)//Symbol.hasInstance用于判断某对象是否为某构造器的实例。因此你可以用它自定义 instanceof 操作符在某个类上的行为。

const obj = {}
// console.log(obj.toString());//[object Object]==>Object叫做对象的自定义标签
// 用Symbol去修改标签
const obj2 = {
	[Symbol.toStringTag]:'XObject'
};
// console.log(obj2.toString());//[object XObject]
// 通过Symbol值作为属性名的一些特性
const obj3 = {
	[Symbol()]:'symbol value',
	foo:'normal value'
}
// 1.在for...in中是无法拿到的,
for(let key in obj3){
	console.log(key)
}
// 2.通过Object.keys()方法也获取不到Symbol值属性名
console.log(Object.keys(obj3));//[ 'foo' ]
// 3.通过JSON.stringify序列化对象为的字符串的情况下,symbol值的属性也会被忽略掉
console.log(JSON.stringify(obj3));//{"foo":"normal value"}
// 总之以上特性使得Symbol值特别适合作为对象的私有属性
// 当然想要获取到Symbol值属性名也是有方法的,Object.getOwnPropertySymbols可以获取到Symbol值属性名,但是获取不到普通属性名
console.log(Object.getOwnPropertySymbols(obj3));//[ Symbol() ]

```
[更多Symbol属性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
## for...of循环
ECMAscript中遍历数据的多种方法:
1. for循环:比较适合遍历普通的数组
2. for...in循环:遍历键值对
3. 函数式的遍历方法 比如一些对象的遍历方法如forEach

---
以上这些遍历方法都有一定的局限性,所以es2015借鉴多种语言引入了一种全新的方式叫做 for...of语言,作为遍历所有数据结构的统一方式,只要明白for...of的工作原理就可以遍历任意一种数据结构
#### for...of循环的基本用法

```
const arr = [100,200,300,400];
for(const item of arr){
	console.log(item);
}
//这种方法取代了数组的forEach方法
arr.forEach(item=>{
	console.log(item)
})
//想比forEach方法,for...of循环可以使用break中止循环
for(const item of arr){
	
	if(item > 200){
		break;
	}
	console.log(item)
}
arr.forEach()//不能中止遍历跳出循环
以前为了中止遍历必须使用数组实例的some和every方法
some方法返回return true中止遍历
const isYes = arr.some(item=>{
	if(item >100){
		console.log(item)
		return true;
	}else{
		console.log(item)
	}
	
})
console.log(isYes)
// every返回 return false中止遍历
const isNoc = arr.every(item =>{
	if(item <300){
		console.log(item)
		return true;
	}else {
		return false;
	}
	
})
console.log(isNoc)
```

```
// 遍历Set
const s = new Set(['foo','bar']);
for(const item of s){
	console.log(item)
}
// 遍历Map
const m = new Map();
m.set('foo',123);
m.set('bar',456);
for(const item of m){
	console.log(item)
}
for(const [key,value] of m){
	console.log(key,value);
}
```

```
// 遍历对象
const obj = {foo:123,bar:456};
for(const item of obj){//报错obj is not iterable,对象不能迭代
	console.log(item)
}
```
for...of说是可以遍历所有的数据类型,那为啥连最基本的对象都不能遍历呢?
## 可迭代接口
上篇说到 for...of循环是es2015最新推出的一种语法,是一种所有遍历所有数据结构的统一方式,但是呢,我们尝试发现它只能遍历一些数组类的数据结构,如果我们尝试遍历普通对象就会报出一种错误,那这 究竟是我说错了还是说有什么原因呢?

其实是这样的,ECMAscript用于表示有结构的数据类型越来越多,从最早的数组和对象到现在的Set和Map,而且我们开发者还可以组合数据类型去定义一些符合业务需求的数据结构,那为了提供一种统一的遍历方式,es2015就提供了Iterable接口,意思是可迭代的,可以把它理解成一种规则标准

例如在ECMAscript当中,任意一种类型都有toString方法,这就是因为它们都实现了统一的规格标准,而在编程语言当中更专业的说法就是他们都实现了统一的接口

那可迭代接口就是可以被for..of统一遍历访问的规则标准,换句话说,只要这个数据结构实现了可迭代接口,它就可以被for...of遍历,那也就是说我们之前尝试了for..of的数据类型,它都已经实现了可迭代(Iterable)接口
![image](82FA34AF15D7499584453419CD29EAF4)
![image](D0A44CFD655C44DA850BA30BA4B92195)
![image](E681E0ED596F48FDAAF24926D4183C69)
第一,以上三个数据类型可以被for...of遍历是以为他们的__proto__里都有Symbol(Symbol.iterator)这个方法;第二,这个方法的名字叫做iterator.那根据这两个理由可以确定,Iterable接口就是我们对象当中必须要挂在一个iterator的方法
> Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用。
#### iterator的方法是干什么的呢?
![image](5BB7AEB68BFA4058896FD3F187CDB87C)
我们得到一个结论,所有被 for...of遍历的数据类型都要实现 Iterable接口,它的内部必须挂载一个iterator方法,这方法返回一个带有next方法的对象,我们不断调用next()方法就可以实现对内部数据的遍历,下面我们演示一下

```
const s = new Set(['foo','bar','hcb']);
const iterator = s[Symbol.iterator]();//调用set对象的迭代方法,获取迭代器对象
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())

/**
 * 返回结果:
 * { value: 'foo', done: false }
 * { value: 'bar', done: false }
 * { value: 'hcb', done: false }
 * { value: undefined, done: true }
 * { value: undefined, done: true }
**/
//其实这就是for...of循环的工作原理
```
## 实现可迭代接口 

```
/**
 * 实现逻辑:三层对象,最外层对象实现了可迭代接口(Iterable),
 * 这个接口约定了内部必须有一个返回迭代器的iterator方法,
 * iterator方法返回的对象实现了迭代器接口(iterator),
 * 这个接口约定了内部必须有一个用于迭代的next方法,
 * 在next方法中返回的对象实现的是迭代结果接口(IterationResult),
 * 这个接口约定的是我们必须有一个value属性,表示当前迭代的数据,值可以是任意 类型,
 * 除此之外还必须有一个done属性,值是布尔值 ,用于表示迭代是否结束
 * */
// const obj = {
// 	//使计算属性名的方式定义到对象当中
// 	[Symbol.iterator]:function(){
// 		//在iterator方法的内部返回一个实现迭代器接口的对象,也就是说在这个对象中要提供一个next方法,实现向后迭代的逻辑
// 		return {
// 			next:function(){
// 				//在next方法内部返回一个迭代结果对象,这个对象有两个成员分别是value和done
// 				return {
// 					value:'hcb',
// 					done:true
					
// 				}
// 			}
// 		}
// 	}
// };
const obj = {
	store:['foo','bar','hcb'],
	//使计算属性名的方式定义到对象当中
	[Symbol.iterator]:function(){
		//在iterator方法的内部返回一个实现迭代器接口的对象,也就是说在这个对象中要提供一个next方法,实现向后迭代的逻辑
		// 因为要迭代一个数组,需要一个下标
		let index = 0;
		// 因为next的this并不是obj对象我们 需要定义 一个 变量接收当前this
		const self = this;
		return {
			next:function(){
				//在next方法内部返回一个迭代结果对象,这个对象有两个成员分别是value和done
				const result =  {
					value:self.store[index],
					done:index >= self.store.length 
					
				}
				index++;
				return result;
			}
		}
	}
};
for(const item of obj){
	console.log('循环体',item)
}//循环体 foo 循环体 bar 循环体 hcb
```
实现迭代器到底有什么用?实现迭代器的目的是什么?
## 迭代器模式

```
//迭代器模式
//场景:你我协同开发一个任务清单
//我的代码==============================
const todos = {
	life:['吃饭','睡觉','打豆豆'],
	learn:['语文','数学','外语'],
	work:['喝茶'],
	// 创建一个统一的遍历接口,调用者就不用关系数据的内部结构是什么样的,更不用担心我的数据结构内部改变后所产生的影响
	each:function(callback){
		const arr = [].concat(this.life,this.learn,this.work)
		for(const item of arr){
			callback(item)
		}
	},
	//创建一个迭代器接口也是一样的,对外提供一个统一的接口
	[Symbol.iterator]:function(){
		let index = 0;
		const arr = [...this.life,...this.learn,...this.work];
		return {
			next:function(){
				return {
					value:arr[index],
					done:index++ >= arr.length
				}
			}
		}
	}
}
//你的代码==============================
// for(const item of todos.life){
// 	console.log(item)
// }
// for(const item of todos.learn){
// 	console.log(item)
// }
// for(const item of todos.work){
// 	console.log(item)
// }
//以上我每增加一个一个属性,你都有增加一个for...of循环,很麻烦
// todos.each((item)=>console.log(item))
// for...of迭代对象
for(const item of todos){
	console.log(item)
}
```
迭代器的意义是:迭代器模式的核心就是对外提供统一遍历的接口,让外部不用再关心内部的数据结构是怎么样的.上面案例中的each方法只适用于当前的数据结构,es2015的迭代器是语言层面实现的迭代器模式,它可以适用于任何数据结构,只需要用代码去实现iterator方法,实现迭代逻辑就可以了


## 生成器 (Generator)
引入这个新的函数的目的在于避免异步编程中回调函数嵌套过深的问题,从而去提供更好的异步编程解决方案,下面我们了解一下生成器的语法以及应用
![image](2B188C0975FD4A529B5E819DE8592BD9)
这说明生成器也实现了迭代器接口协议,一般生成器函数都会搭配yield关键词,yield关键词和return都可以返给函数本身值,但是yield不能中止函数体的运行

```
// 定义生成器函数就是在普通的function后面跟一个*号

function * foo(){
	console.log(1111)
	yield 100
	console.log(2222)
	yield 200
	console.log(3333)
	yield 300
}
const generator = foo();//生成器函数会帮我们返回一个生成器对象,调用这个生成器对象的next方法才会让这个函数的函数体开始执行,在执行过程中一旦遇到yield关键词,函数就会暂停下来,而且yield后面的值将会作为函数的结果返回,如果继续调用next方法,函数就会从暂停的位置继续执行,周而复始一直到这个函数完全结束,next方法返回的done的值也会变成true
// 普通函数会先打印hcb再打印generator,但是生成器函数只打印出一个Generator对象
console.log(generator);
console.log(generator.next());//打印一次出现一次说明函数yield后面的语句还没有执行,因为如果执行力它就会把后面全部打印出来
console.log(generator.next())
console.log(generator.next())
console.log(generator.next())
/**
 * Object [Generator] {}
 * 1111
 * { value: 100, done: false }
 * 2222
 * { value: 200, done: false }
 * 3333
 * { value: 300, done: false }
 * { value: undefined, done: true }
 * */
 * */
```
生成器函数的最大特点就是惰性函数,抽一下,动一下
## 生成器应用

```
//案例:发号器
function * createIdMaker(){
	let id = 1;
	while (true){//不用担心会出现不断循环的问题
		yield id++;//yield每执行一次都会暂停函数体
	}
}
const idMaker = createIdMaker();
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
console.log(idMaker.next())
```


```
/Generator 应用
//案例1------------------------------------------------------
const todos = {
	store:['foo','bar','hcb'],
	[Symbol.iterator]:function(){
		let index = 0;
		const store = this.store;
		return {
			next:function(){
				const result = {
					value:store[index],
					done:index++ >= store.length
				}
				return result;
			}
		}
	}
}
for(const item of todos){
	console.log(item)
}
// ----------------------------
// 使用Generator替换next函数
const todos = {
	store:['foo','bar','hcb'],
	[Symbol.iterator]:function * (){
		const store = this.store;
		for(const item of store){
			yield item
		}
		
	}
}
for(const item of todos){
	console.log('todos',item)
}
// 案例2------------------------------------------------------------
const libarys = {
	life:['吃饭','睡觉','打豆豆'],
	learn:['上课','读书','学新技术'],
	work:['业务','开会'],
	[Symbol.iterator]:function *(){
		const arr = [...this.life,...this.learn,...this.work];
		for(const item of arr){
			yield item
		}
	}
}
for(const item of libarys){
	console.log('libary',item)
}
```
Generator最重要的还是解决异步编程中回调函数嵌套过深的问题

## ES Modules(语言层面的模块化规范)
在模块化开发会详细介绍
## ECMAscript2016 概述
- Array新增includes方法,可以查找指定的值包括NaN,如果查找到返回true否则返回false,比indexOf方法好用
- 新增指数运算符:这种运算符对于数学密集型应用是一个很好的补充
```
// 传统指数运算符
console.log(Math.pow(2,10))//相当于2的10次幂
// es2016指数运算符
console.log(2 ** 10)
```
## ECMAscript2017 概述

```
//ECMAscript2017
const obj = {
	foo:'value1',
	bar:'value2'
}
//Object.values --------------------------------------------
// 返回对象的所有属性值
console.log(Object.values(obj));//[ 'value1', 'value2' ]
//Object.entries (恩吹斯)--------------------------------------------
// 以数组的形式返回对象的键值对,可以配合for...of遍历
console.log(Object.entries(obj));//[ [ 'foo', 'value1' ], [ 'bar', 'value2' ] ]
for(const [key,value] of Object.entries(obj)){
	console.log(key,value)
}
/**
 * foo value1
 *bar value2
 * */
 // Map函数需要的 就是[ [ 'foo', 'value1' ], [ 'bar', 'value2' ] ]这种格式的数组,所以可以借助Object.entries将对象转换成Map类型的对象
 console.log(new Map(Object.entries(obj)));//Map { 'foo' => 'value1', 'bar' => 'value2' }

//Object.getOwnPropertyDescriptors --------------------------
// 获取对象当中属性的完整描述信息,主要配合es2015的get,set使用
const p1 = {
	a:123,
	b:456,
	get sum(){
		return this.a + this.b
	}
}
// console.log('sum',p1.sum);//sum 579
// const p2 = Object.assign({},p1);
// p2.a = 4
// console.log('sum',p2.sum);//sum 579
// 为什么p2的sum的值没有改变的呢?这是因为object.assign在复制对象时把sum当成普通的属性去对待了,所以才会出现这种情况,
// 我们可以使用Object.getOwnPropertyDescriptors属性获取对象的信息
const descriptors = Object.getOwnPropertyDescriptors(p1);
console.log('descriptors',descriptors)
// Objct.defineProperties将对象信息定义到一个新的对象当中
const p2 = Object.defineProperties({},descriptors)
p2.a = 789;
console.log(p2.sum)
// String.prototype.padStart / String.prototype.padEnd --------------------
// ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。

// 'x'.padStart(5, 'ab') // 'ababx'
// 'x'.padStart(4, 'ab') // 'abax'

// 'x'.padEnd(5, 'ab') // 'xabab'
// 'x'.padEnd(4, 'ab') // 'xaba'
// 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。

// 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。
const books = {
	a:5,
	b:16,
	c:118
}
for(const [name,count] of Object.entries(books)){
	console.log(`${name.padEnd(16,'-')}|${count.toString().padStart(3,'0')}`)
}

// 这两个属性的效果就是用给定的字符串去填充目标字符串的开始或结束的位置,知道我们的计算达到指定长度为止
// 函数参数中添加尾逗号
function foo(
	name,
	age,
){
	
}
// Async / Await解决异步函数嵌套过深的问题,本质上是使用promise的语法糖
```
# JavaScript异步编程

 
## 异步编程 单线程javascript异步方案
#### javascript 采用单线程模式执行工作的原因?
与最早的设计初衷有关,JavaScript最早是运行在浏览器上的脚本语言,目的是实现页面上的动态交互,而实现页面交互的核心就是DOM操作,这也就决定了它必须实现单线程模型,否则会出现多线程同步的问题,假设DOM操作是多线程工作,这个修改了DOM,同时那个删除了DOM,这样浏览器就不能决定以哪个结果为准,所以为了避免线程同步的问题,JavaScript被设计成单线程模式工作

JavaScript单线程是指在js执行代码环境当中,负责执行代码的线程只有一个,这种模式的优点是更安全,更简单,缺点是遇到耗时的任务需要等待排队去实现,这会导致整个程序会被拖延出现假死的情况
![image](BC607CCB725C408BAC089FEF39F76C56)
## 同步模式
同步模式指我们代码中的任务必须依次执行,代码中的任务必须等待上一个任务执行完才能执行,程序的执行顺序和代码的编写顺序是完全一致的,这种方式会比较简单,在单线程情况下我们大多数任务都会以同步模式去执行,这里的同步指排队执行

js在执行过程中维护了一个正在执行的工作表,在这里我们会记录他当前做的事情,当工作表中的任务全部清空以后,这轮工作算是结束了

```
// 同步执行顺序 
//顺序0:首先会加载整体代码,在调用栈中压入一个匿名函数调用 
console.log('start');//顺序1
function bar(){
	console.log('bar');//顺序3
}
function foo(){
	console.log('foo');//顺序2
	bar()
}
foo()
console.log('end');//顺序4

// start
// foo
// bar
// end
```

这种排队执行的机制存在一个很严重的问题:如果其中某一行代码执行时间过长,后面的任务就会被延迟,那我们把这种延迟称之为阻塞,这种阻塞对于用户而言会有卡顿或卡死,所以需要异步模式来解决编程当中的耗时操作,如浏览器端的ajax或nodejs中的大文件读写
## 异步模式
异步模式不会等待这个任务的结束才开始执行下一个任务,对于耗时操作,它都是开启过后就立即执行下一个任务,耗时任务的后继逻辑都是通过回调函数的方式定义,在内部呢,耗时任务完成过后就会自动执行传入的回调函数

异步模式的重要性:没有异步模式,JavaScript无法处理大规模的耗时任务

相比于同步模式,异步的执行顺序是你不能确定的,跳跃的

```
// 异步执行顺序
//顺序0:首先会加载整体代码,在调用栈中压入一个匿名函数调用 
console.log('start');//顺序1
// 遇到异步调用,放在web apis中执行
setTimeout(function timer1 (){//注意倒计时器是单独工作的并不受我们的js线程影响
	console.log('timer1');//顺序4
},1800)
setTimeout(function timer1 (){
	console.log('timer2');//顺序3
	setTimeout(function timer1 (){
		console.log('timer3');//顺序5
	},1000)
	
},1000)
console.log('end');//顺序2
// start
// end
// timer2
// timer1
// timer3

```

- 事件循环机制负责监听调用栈和消息队列,当调用栈中多有任务都结束后,事件循环机制会从消息队列取出第一个回调函数,然后压入到调用栈,此时的消息队列是空的,程序也就暂停了,等到计时器的倒计时结束后,先结束的timer2会被放在消息队列的第一位,time1放在消息队列的第二位,一但消息队列发生变化,时间循环机制就会监听到,然后把消息队列中的第一个time2压入调用栈,继续执行time2,此时对于调用栈相当于开启了新的执行,执行顺序是一致的,遇到异步调用就放在web api中执行,如此不断重复,直到调用栈和消息队列都没有需要执行的任务了,整体的代码就结束了
- 如果说调用栈是一个正在执行的工作表,那么消息队列就是一个代办的工作表,而事件循环就是先执行调用栈中的任务,然后再去执行消息队列中的任务,以此类推,这一过程,可以随时往消息队列里放置任务,这些任务会排队等待事件循环,然后在消息队列里按顺序压入到调用栈执行
- 以上就是异步调用在JavaScript的实现过程以及它的基本原理,整个过程都是通过内部的消息队列和事件循环去实现的
![image](A66498E444824F739E55D67B4543C8FB)
> 这里我们需要注意的是JavaScript是单线程的而我们的浏览器不是单线程的,具体就是通过JavaScript调用的某些内部的api并不是单线程的,例如计时器,内部有一个单独的线程在倒数,在时间到了过后会将我们的回调函数放入消息队列,也就是说这样一件事情是有一个人单独去做的

同步模式的api是代码执行完才会继续往下走比如console.log;
异步模式的api就是下达这个任务开启任务的指令后就会继续执行,不会等待代码执行结束,如setTimeout
## 回调函数 (所有异步编程方案的根基)
![image](495827D1A8BC4AF49B007B807AEEE514)
由调用者定义,交给执行者执行的函数被称为回调函数,具体用法就是把函数作为参数传递

```
function foo (callback){
	setTimeout(function(){
		callback()
	})
}
foo(function(){
	console.log('这是回调函数')
	console.log('调用者定义这个函数,执行者执行这个函数')
	console.log('其实就是调用者告诉执行者异步任务结束时应该做什么')
})
```
除了这种传递参数的回调函数外还有几种常见的异步方式如事件机制和发订阅,个人认为这些都是基于回调函数的变体
## Promise
直接使用传统回调的方式去完成复杂的异步流程,无法避免大量的回调函数嵌套,这也就导致常说的回调地狱的问题,为了避免回调地狱的问题,commonjs社区率先提出来Promise规范,目的是为异步编程提供一个更合理更强大的统一解决方案,后来在ES2015当中被标准化,成为语言规范

所谓Promise就是一个异步对象,用来表示一个异步任务结束之后最终结束过后究竟是成功还是失败,就像是内部对外界做出来一个承诺(promise),一开始这个承诺是待定状态(Pending),最终有可能成功(fulfilled),也有可能失败(rejected)
![image](21E89E13433244CEB1B3F6E58E86B5F0)
不管这个承诺是成功还是失败都会有相应的反应,也就是说承诺状态最终明确过后,都会有相对应的任务自动执行,而且这种承诺会有一个很明显的特点就是一但明确了结果过后就不可能发生改变了
![image](6C65F260EBE54C6A97BB96488D6C0614)

```
// Promise 基本示例
const promise = new Promise(function(resolve,reject){
	// 这里用于兑现承诺
	// resolve('200');//承诺达成
	reject(new Error('Promise rejected'));//承诺失败
})
promise.then(function(value){
	console.log('resolved',value)
},function(error){
	console.log('rejected',error)
})
console.log('end')
// 需要注意的是,即便Promise当中没有任何的异步操作,
// then方法指定的回调函数仍然会在回调队列中排队,
// 也就是说这里需要等同步代码执行完了才回去执行
```
## Promise 使用案例
用Promise 封装ajax请求

```
// Promise 封装ajax
function ajax(url){
	return new Promise((resolve,reject)=>{
		const xhr = new XMLHttpRequest();
		xhr.open('GET',url);
		xhr.responseType = 'json'
		xhr.onload = function(){
			if(this.state === 200){
				resolve(this.response)
			}else{
				reject(new Error(this.statusText))
			}
		}
		xhr.send()
	})
}
ajax('apis/users.json').then((resolve)=>{
	console.log(resolve)
},(reject)=>{
	console.log(reject)
})
```

## Promise的误区
Promise的本质是定义异步任务结束后的所需要执行的任务


嵌套使用的方式是Promise最常见的使用误区

```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
// 回调地狱
ajax('/api/users.json').then(function (res) {
  ajax('/api/users.json').then(function (res) {
	ajax('/api/users.json').then(function (res) {
	  ajax('/api/users.json').then(function (res) {
	    ajax('/api/users.json').then(function (res) {
	      
	    })
	  })
	})	
  })
})
```
以上这种情况嵌套函数没有意义，而且增加了Promise的复杂度

正确做法是通过Promise的then方法链式调用，尽可能使异步任务扁平化
## Promise链式调用
链式调用能最大限度的避免嵌套

Promise内部会返回一个Promise对象，并且返回的对象是一个新的Promise对象，其目的是实现一个链条，表示一个承诺过后会返回一个新的承诺，每个承诺可以负责一个异步任务，并且相互之间没有任何影响

```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
ajax('/api/users.json').then(function (res) {
  console.log(111111)
}) .then(function (res) {
  console.log(222222)
}) .then(function (res) {
  console.log(333333)
}) .then(function (res) {
  console.log(444444)
}) .then(function (res) {
  console.log(555555)
}) .then(function (res) {
  console.log(666666)
}) 
```
![image](FE383F245F504016918A39AFFEE53819)
每个Promise对象的第一个then方法都可以return一个Promise对象，用于链式调用下一个then方法当中的回调，这样可以避免不必要的回调嵌套

```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
ajax('/api/users.json').then(function (res) {
  console.log(111111)
  console.log(res)
  return ajax('/api/users01.json')
}) .then(function (res) {
  console.log(222222)
  console.log(res)
  return ajax('/api/users02.json')
}) .then(function (res) {
  console.log(333333)
  console.log(res)
})
```
![image](FDA938A2657F4D1FB549908375D9E3A6)

需要注意的是前面then方法回调的返回值会作为后面then方法回调的参数，如果回调中返回的是Promise对象，后面的then方法的回调函数会等待他的结果
#### 总结
![image](731400F69EF7491484BF8B734748BC9A)

## Promise异常处理

###### 1.rejected回调
只能捕获到当前Promise对象的异常
```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
ajax('/api/usersc.json').then(function (resolve) {
  console.log(resolve)
 
},function(reject){
	console.log('异常结果',reject)
	return ajax('/error-url')
})
```

![image](86361CE890494D66B756D60CDE05132E)
###### 2.catch方法
catch方法是then方法的别名相当于

```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
ajax('/api/usersc.json').then(function (resolve) {
  console.log(resolve)
 
}).catch(undefined,function(error){
		console.log(error)
	})
```
![image](D902968F492D433299FD7CCCEB061DCE)

catch更适合链式调用，它能够捕获Promise链式调用时前面多有Promise的异常信息

```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
ajax('/api/users.json').then(function (resolve) {
  console.log(resolve)
	return ajax('/error-url')
}).catch(undefined,function(error){
		console.log(error)
	})
```
![image](0C03D5375D73435091B1C1F979F5904C)

###### unhandledrejection
unhandledrejection 用于处理一些没有被手动捕获的异常
在浏览器注册window上面，在node，注册在process上面

```
window.addEventListener("unhandledrejection", event => {
  const {reason,promise} = event;
  console.log(reason,promise)
  // reason失败的原因--一般是错误的对象
  // promise:错误的promise对象
});

```

```
process.on("unhandleRrejection", (reason,promise) => {
 
  console.log(reason,promise)
  // reason失败的原因--一般是错误的对象
  // promise:错误的promise对象
});

```
[更多内容](https://developer.mozilla.org/zh-CN/docs/Web/Events/unhandledrejection)
## Promise 静态方法
###### Promise.resolve()
快速把一个值转换成Promise对象

```
Promise.resolve('fpp').then(res=>console.log(res));//fpp
```
等同于

```
new Promise((resolve,reject)=>resolve('fpp')).then(res=>console.log(res));//fpp
```
通过Promise.resolve包装一个Promise对象，得到的是原本的Promise对象

```
const promise01 = ajax('/api/users.json');
const promise02 = Promise.resolve(promise01);
console.log(promise01 === promise02);//true
```
特殊情况：如果传入一个对象，这个对象也有then方法，包含resolve和reject两个参数，那么这个对象也可以被当作Promise对象去执行

```
Promise.resolve({
	then(onFullfilled,onRejected){
		onFullfilled('foo')
	}
}).then(function (resolve) {
  console.log(resolve);//foo
})

```
这种特殊的情况可以把第三方的then方法转成promise对象

###### Promise.reject()
快速创建失败的Promise对象，传入的数据是失败的理由


## Promise并行执行
如果 多个接口相互之间没有依赖，我们可以一起请求，可以减少消耗的时间
###### Promise.all()
Promise.all会等待所有的Promise都结束才会执行
```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
Promise.all([
	ajax('/api/users.json'),
	ajax('/api/users01.json')
])//，两个任务都成功了才会返回到then方法，成功返回包含两个Promise对象结果的数组
.then(resolve=>console.log(resolve))
.catch(error=>console.log(error))//如果两个任务有一个失败了,另外一个也以失败结束
```
> 串行和并行相结合

```
ajax('/api/url.json').then((res)=>{
	const urls = Object.values(res)
	const arr = [];
	urls.map((v,i,a)=>{
		arr.push(ajax(v))
	}) 
	return Promise.all(arr)
})
.then(resolve=>console.log(resolve))
.catch(error=>console.log(error))
```
![image](8169B7A4A89F41FC8B47FFCEF0E3604E)
###### Promise.race()
跟着所有完成的任务中第一个完成任务的一起结束

```
const a = ajax('/api/users.json');
const b = new Promise(function(resolve,reject){
	setTimeout(function(){
		reject(new Error('异常'))
	},500)
})

Promise.race([
	a,
	b
])
.then(resolve=>console.log(resolve))
.catch(error=>console.log(error))
//注意：通过network的online调成show 3G查看
```
## Promise 执行时序 宏任务/微任务

```
// 微任务
console.log('start')
setTimeout(function(){
	console.log('settimeout')
},0)
Promise.resolve()
.then(res=>console.log('promise1'))
.then(res=>console.log('promise2'))
console.log('end')
```
![image](680A9D02DA884228948D38352023066C)

回调队列中的任务被称之为宏任务，而宏任务执行过程中有可能会临时加上一些额外的需求，这些额外的需求可以选择作为一个新的宏任务进入任务队列中排队，也可以作为当前任务中的微任务，之间在当前任务结束后立即去执行，而不是回到队伍的末尾重新排队，这就是宏任务和微任务的差异，而Promise的回调是作为微任务执行的，他就会在本轮结束的末尾继续执行，这也就是为啥先打印promise再打印settimeout的原因，因为settimeout是以宏任务的形式进入队列的末尾再执行的

微任务是后来引入的，提高了整体的响应能力，目前绝大部分异步调用都是作为宏任务执行，而Promise&&MutationObserver以及node的process.nextTick都会作为微任务之间在本轮调用末尾执行
## Generator异步方案（上）
generator执行流程

```
function * foo () {
	try {
		console.log('foo')
		const res = yield 'foo';
		console.log(res);//res能通过next方法传递参数的方式传递进来值
	}catch(e){
		console.log(e)
	}
}
const generator = foo();
const result = generator.next();
console.log(result)
const result2 = generator.next('bar');
console.log(result2)
generator.throw(new Error('异常'))
```
![image](1EAEDBE4FC5A43AE9EBA9CBB096A88A1)
## Generator异步方案（中）
可以用yield暂停生成器函数的一个特点来实现更优的异步编程体验

```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
function * main (){
	const users = yield ajax('/api/users.json');
	console.log('users',users)
	const users01 = yield ajax('/api/users01.json');
	console.log('user01',users01)
}
const generator = main();
const result = generator.next();//拿到ajax请求结果
console.log(result);//{value: Promise, done: false}
const { value,done } = result;//获取请求ajax返回的promise对象


value.then((data)=>{
	// 将ajax得到的值传递给main方法的users
	const {value,done} = generator.next(data);//以此类推
	console.log('done2',done)
	if(done) return;
	value.then((data)=>{
		// 将ajax得到的值传递给main方法的users
		const {value,done} = generator.next(data);
		console.log('done3',done)
		if(done) return
		value.then((data)=>{
			// 将ajax得到的值传递给main方法的users
			const {value,done} = generator.next(data);
			console.log('done4',done)
			
		})
		
		})
	
})


```
这种异步编程体验，对于promise内部彻底消灭了promise的回调，有一种近乎于同步代码的体验

## generator异步方案（下）
递归执行generator函数

```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
function * main (){
	try {
		const users = yield ajax('/api/users.json');
		console.log('users',users)
		const users01 = yield ajax('/api/users01.json');
		console.log('user01',users01)
	}catch(e){
		console.log(e)
	}
}
const generator = main();
// 递归函数执行Generator
function handleResult(result){
	const { value,done } = result;//获取请求ajax返回的promise对象
	value.then((data)=>{
		// 将ajax得到的值传递给main方法的users
		const result = generator.next(data);//以此类推
		const { value,done } = result;
		if(done) return;
		handleResult(result)
	},error =>{
		generator.throw(error)
	})
}
handleResult(generator.next())
```
更进一步

```
// 封装co函数，参数传递generator函数
function co(generatorFunc){
	const generator = generatorFunc();
	// 递归函数执行Generator
	function handleResult(result){
		const { value,done } = result;//获取请求ajax返回的promise对象
		value.then((data)=>{
			// 将ajax得到的值传递给main方法的users
			const result = generator.next(data);//以此类推
			const { value,done } = result;
			if(done) return;
			handleResult(result)
		},error =>{
			generator.throw(error)
		})
	}
	handleResult(generator.next())
}
co(main)
```
> generator异步方案更有利于异步编程扁平化

[异步执行解决方案co（2015年实现）](https://github.com/tj/co)
## async/await 语法糖
语言层面的异步编程标准

```
function ajax (url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'json'
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    xhr.send()
  })
}
async function main (){
	try {
		const users = await ajax('/api/users.json');
		console.log('users',users)
		const users01 = await ajax('/api/users01.json');
		console.log('user01',users01)
	}catch(e){
		console.log(e)
	}
}
const promise = main()
console.log(promise)
promise.then(res=>{
	console.log('all finfish')
})
```
async/await相比generator不需要类似co这样的一个执行器，是语言层面的标准异步编程语法，其次async函数会返回一个promise对象，更有利于代码的整体控制

值得注意的是await只能在async的内部去使用，不能在外层单独使用

# typescript

## 强类型与弱类型
再具体介绍JavaScript的类型系统的问题之前，我先来解释两组在区分不同编程语言时经常提及的名词，分别是强类型和弱类型，还有就是静态类型动态类型，那他们呢，分别是从类型，安全和类型检查这两个维度去区分了不同的编程语言，首先我们来看类型安全的角度，那从类型安全角度来说，编程语言作为强类型和弱类型，那这种强弱类型的概念最早是1974年的时候，美国有两个计算机专家提出的，那当时呢，对强类型这个概念的定义，就是在语言层面就限制我们函数的。实参类型必须要跟形参类型完全不同，例如呢，有一个foo函数，那他需要接受一个整型的参数，我们去调取的时候就不允许直接去传入一个其他类型的值，那么可以选择在传入之前呢，先将我们这个值转换成一个整型的数字，然后再进入，而弱类型则完全相反，在语言方面并不会去限制我们实参的类型，即便说我们这个函数需要的参数是整型的数字，我在这时仍然可以传入任意类型的数据，语法上是不会报错的，在运行中可能出现问题与法律问题，由于这种强弱之分呢，根本不是某一个权威机构的利益，而且呢，当时这两位计算机的专家也没有给出一个具体的规则，所以说就导致了后人对这种鉴定方式的细节出现了一些不一样的理解，但是整体上大家的鉴定方式都在描述强类型的，他是有更强的类型约束，而弱类型呢，他几乎没有什么类型约束，那我个人比较同意一个说法，就是强类型语言当中，不允许有任意的隐式类型转换，而在弱类型语言当中，和允许任意的隐式类型数据转换.例如我这需要一个数字,你这放一个字符串也是可以的.
### 总结
这里我们总结一下强类型和弱类型，这两种类型之间的差异呢，就是不允许任何的隐式类型转换,而弱类型,它是比较随意的，它可以任意的隐式类型转换，当然这只是我理解的一种强类型的激励方式，并不是一个说法，业界呢，也根本没有一个说法，你可以根据你自己的理解去做一个定义，那对于你可能会想到我们在代码中的变量类型可以随时改变主意的特点，那其实这并不是强弱类型之间的区别，我就拿python来说呢，它是一门强类型语言，但是呢，它的变量仍然是可以随时改变类型的特点，在很多资料中可能都表示有些不太妥当，他们在说python是一门弱类型语言，其实不是这样的。
## 静态类型和动态类型
那从类型安全的角度强类型和弱类型之分，在类型检查的角度，我们可以将变成语言分为静态类型语言和动态类型语言,关于静态语言和动态语言之间的差异呢，并没有什么争议,大家都很统一，对于静态语言最主要表现就是一个变量，声明时它的类型就明确的，而且呢，在变量声明过后它的类型就不允许被修改了，那相反，动态类型语言的特点呢，就是在运行阶段才能够明确一个类型，而且变量的类型也可以随时发生变化

```
var foo = 10;//声明是默认是number类型
foo = 'cc';//转换成了字符串类型
```


我们可以说在动态类型当中的变量是没有类型的，变量当中所存放的值是有类型的,那JavaScript呢，就是一门标准的动态类型语言呢，总的来说从类型安全角度一般将编程语言分为强类型和弱类型，两者之间的区别就是是否允许随意的隐式类型转换，那从类型检查的角度分为静态类型和动态类型，它两者之间的区别就是是否允许修改变量的类型。
> 以下常用语言在这两种维度下的表现

![image](6FF54E90672B47AD85A4FDE6C7E8191B)

## JavaScript类型系统的特征
由于JavaScript是一门弱类型而且是动态类型的语言,本身的系统是非常薄的，甚至也可以说扎实的根本就没有类型系统，那这种语言的特征，用一个比较流行的词来说，就是任性，因为他几乎没有任何类型限制，所以我们JavaScript这门语言呢，也是极其灵活多变的，但是在这种灵活多变的表象背后，丢失掉的就是类型系统的可靠性，我们在代码当中每每遇到变量都要担心他到底是不是我们想要的类型，整体感受用另外一个流行词来说就是不靠谱.

可能有人会问为什么JavaScript不能设计成强类型或者静态类型这种更靠谱的语言呢?

这个原因自然跟詹姆斯的背景有关，首先，在早前根本就没想到JavaScript的应用会发展到今天，这种规模，那最早的JavaScript应用他根本不会太复杂，需求都非常简单，很多时候几百行代码甚至是几十行就搞定了,那在这种一眼就能够看到头的这种情况下，类型系统限制呢，就显得很多余或者是很麻烦的;

其次呢，JavaScript是一门脚本语言，那脚本语言的特点就是不需要编译，就直接在运行中去运行，换句话说，JavaScript他是没有编译环节的，那即便把它设计成一个静态类型，语言也没有意义，因为静态类型语言需要在编译阶段去做类型检查,而JavaScript没有编译环境,根据以上这些原因JavaScript成为了一门灵活的弱类型/动态类型语言.

在现在大规模应用的情况下,JavaScript的优势变成了短板!
## 弱类型的问题

- 接下来我们具体来看，JavaScript弱类型语言在去应对大规模开发时，有可能会出现一些常见问题，当然我们这里所列的问题呢，只是冰山一角，不过他们也都能反映出一些问题，那首先我们来看第一个例子呢，


```
// javascript 弱类型产生的问题
const obj = {}
// obj.foo();//我们去调用这个方法，那很明显的对象当中并不存在这样的方法，但是呢，在语言的语法方面，这样写是可行的

```


我们去定义这个obj对象，然后呢，我们去调用foo这个方法，那很明显的对象当中并不存在这样的方法，但是呢，在语言的语法方面，这样写是可行的，只是呢，我是把代码放在node环境中去运行，就会报出一个错误，那也就是说，在JavaScript的这种弱类型语言当中，我们就必须要等到运行阶段。才能够去发现代码当中的一些类型异常，而且如果这里并不是立即去执行去做方法，而是在某一个特定的时间才去执行，例如

```
setTimeout(() => {
    obj.foo()
}, 1000000);
```

那程序呢，在刚刚启动运行时还没有办法去发现异常，一直等到代码执行了，才有可能去抛出这样一个异常，那也就是说，如果我们在测试的过程中没有测试到这一行代码,那这样的隐患就会被留在我们的代码当中。

- 而如果是强类型语言的话，那在这里我们直接去调用一个不存在成员，这里语法上就会报出错误，根本不用等到我们去运行代码，我们再来看第二个例子呢


```
function sum(a,b){
    return a + b;
}
console.log(sum(100,100))
console.log(sum(100,'100'));//报错
```

sum就是去计算这两个数的和,我们玩的是两数的话，结果自然是正常的，但是如果我们候传入的是字符串，那这种情况下，我们这个函数的作用就完全发生了变化，那他会返回我们对两个字符串连接过后的结果，那这就是因为类型不确定所造成的一个最典型的问题呢，有人说我们可以通过自己的约定去规避这个问题，的确通过约定方式是可以规避这个问题，但是你要知道约定是根本没有任何保障的，特别是在多人集中开放情况下，我们根本没办法保证每个人都能遵循所有原因，而我们用强类型语言的话，那这种情况就会彻底避免掉，因为在强类型语言当中，如果我们要求传入的数字，那你传入的是其他类型的值,在语法上就行不通。
- 那再来看第三个例子，

```
const obj = {}
obj[true] = 100
console.log(obj['true'])
```


这里呢，我们先去创建一个对象，然后呢，通过索引器的语法去给对象添加属性，我前面也介绍过对象的属性，它只能够是字符串或者是eS6所推出的那个symbol，但是呢，由于JavaScript是弱类型的，所以我们可以在索引当中使用任意类型的值作为属性，而在他的内容会自动转换成字符串，比如我们会这个obj去添加true作为属性，那最终的对象，他实际的属性就是字符串的true，也就是说，我们现在使用字符串也可以取到这样的值。有什么问题，如果说我们不知道对象属性名会自动转换成这样一个点，那这里呢，你就可能会感觉很奇怪，那这种奇怪的根源，就是我们用的是一个比较随意的弱类型语言，那如果是强行的话，这个问题也可以彻底避免，在强烈的情况下这里，所以他明确有类型要求，我们不满足类型，要求这样一个成员在语法上就行不通。

> 那总结下这里的三个例子，第一个例子当中，因为弱类型的关系，我们当中一些类型异常，需要等到运行时才能够发现，而在第二个例子当中因为弱类型关系,他类型不明确，就会造成我们函数功能有可能发生改变，在第三个当中，因为弱类型关系就出现了我们对对象索引器的一种错误的用法，综上，弱类型语言它的弊端是使得明显的,只是在代码量小的情况下，这些问题我们可以通过约定方式去规避，而对于一些开发周期特别长的大规模项目那这种。君子约定的方式仍然会存在隐患，那只有在语法层面的强制要求才能够提供更可靠的保障，所以说呢，强类型语言的代码，在代码可靠程度上是有明显优势的，那使用强类型语言呢，就可以提前消灭一大部分有可能会存在的类型异常，而不必等到我们在运行过程中再去慢慢的一半。

## 强类型语言的优势
1. 错误更早的暴露
2. 代码更智能,编码更准确
>强类型语言编辑器能时时刻刻提醒你代码的错误或异常

```
// 强类型语言的优势
function render (element){
    element.className="container"
    element.innerHtml = '你好'
}
```

3. 重构更牢靠
```
// 重构
const until = {
    aaa:()=>{
        console.log('until')
    }
}
```
4. 减少不必要的类型判断


```
// 类型判断
function sum(a,b){
    // 强类型不需要这种判断
    if(typeof a !=== 'number' || typeof b !=== 'number'){
        throw new TypeError('参数必须是数字')

    }
    return a + b
}
```
![image](E46E31B8F25F4900A682CDF63B704423)

## Flow（JavaScript的静态类型检查器）
Flow可以弥补JavaScript带来的一些弊端，为JavaScript提供了更完善的类型系统
> Flow工作原理：在代码当中通过添加一些类型注解的方式，来去标记我们代码当中每个参数，每个变量，它是什么类型的，然后Flow可以根据这些类型注解就可以检查代码当中是否会存在类型使用的异常，从而去实现我们在开发阶段对类型异常的一个检查，这就避免了我们在运行阶段去发现类型的错误
- 类型注解 ":类型"的结构
- 特点1：代码当中的类型注解可以通过Babel或Flow官方提供的模块自动去剔除，所以在生产环境当中这些注解不会有任何的影响
- 特点2：Flow并不需要给每个变量都添加注解，可以根据需要在需要的地方添加类型注解，不需要可以不添加
## Flow快速上手
1. 因为Flow是以一个npm模块化的形式去工作的，我们需要初始化package.json用于管理我们的项目依赖

```
yarn init -yes
```
2. 安装Flow，作为项目依赖安装，更加方便管理，安装成功后可以在node_modules/bin中找到flow的可执行文件，那么我们可以在命令行当中执行flow，用于检测项目当中对应的代码中的类型异常

```
yarn add flow-bin --dev
```
3. 使用类型注解的前提是在当前js文件的上方添加注释标记@flow,这样flow在执行检测时才会检查这个文件

```
//@Flow
function sum(a:number,b:number){
	return a + b
}
sum(10,10)
sum('10','10')
```
4. 在命令行创建flow初始化文件

```
yarn flow init
```
生产.flowconfig文件
5. 运行flow，进行类型检查

```
yarn flow 
```
![image](F5BC41ED6B5F450D9AA32A891BFEA453)

6. 在flow完成过后可以在命令行使用命令结束这个服务
```
yarn flow stop
```


---
小知识:在vscode--file--preference--setting搜索javascript validate勾掉对勾可以关闭js的语法检查


---

## 编译 （通过编译移除类型注解）
类型注解并不是js的标准语法,当添加类型注解过后,代码是没有办法正常运行的,例如

```
//@flow
function sum(a:number,b:number){
	return a + b;
}
sum(100,100)
sum('100','100')
```
执行命令

```
node flow_dome01.js
```

![image](5A5F1A47FCB24CBEA701E62AF8CEB437)

解决这种问题可以移除类型注解,因为类型注解实际上使我们在编码环节使用的,在运行中实际上是没有必要的,
### 移除类型注解的两种解决方案
#### 1.使用flow官方提供的flow-remove-types模块,这也是 最快速最简单的方案

```
//命令行安装依赖
yarn add flow-remove-types --dev
```
运行flow-remove-types,生成变编译后的文件

```
//yarn flow-remove-types [输入文件路径] -d [输出的文件路径]
//-d是转换的意思
yarn flow-remove-types . -d dist
```
![image](A8A8DF1F275E458C97FFC150C26E1E18)
这样就没有类型注解了

```
//   dist/flow_dome01.js  
function sum(a       ,b       ){
	return a + b;
}
sum(100,100)
sum('100','100')
```
把所有的文件都放置src文件夹能够避免误删第三方的文件
```
//yarn flow-remove-types [输入文件路径] -d [输出的文件路径]
//-d是转换的意思
yarn flow-remove-types src -d dist
```
![image](CDD25A0CC527473EA74D42ABD3410ACC)
> flow方案是如何解决js的弊端的?把编写的代码和实际运行的代码分开,中间加入了编译的环节,这样我们就可以使用一些扩张语法,使得类型检测变得可能

#### 2.babel插件自动移除代码当中的类型注解
安装babel插件
- 安装 babel的核心模块 
- babel的cli工具,能够让我们使用babel命令去完成编译
- 安装babel的preset-flow 包含了我们转换flow类型注解的插件
``` 

yarn add @babel/core @babel/cli @babel/preset-flow --dev

```
配置.babelrc文件

```
{
	"presets":["@babel/preset-flow"]
}
```
运行babel编译命令

```
yarn babel src -d dist
```
package.json 

```
{
  "name": "dome20200524",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "devDependencies": {
    "@babel/cli": "^7.8.4",
    "@babel/core": "^7.9.6",
    "@babel/preset-flow": "^7.9.0",
    "flow-bin": "^0.125.1",
    "flow-remove-types": "^2.125.1"
  }
}

```
## flow开发工具插件
在vscode搜索插件flow看到Flow Language Support下载,能够让我们在保存代码后直观的看到类型检查的报错
![image](69F0B83654F244769973EF2A25707E6E)
![image](B35AF837E18B469C82B0FA5071122F07)

[更多开发工具插件](https://flow.org/en/docs/editors/)
## 类型推断 type inference
flow能够根据代码的实际情况自动推断出数据类型

```
/**
 * 类型推断
 * @flow
*/
function cf(n,m){
    return n*m
}
cf('100','100')
```
![image](33930F61852040BA80A1A5A17756DB7D)
我们更加建议为代码的每一个成员添加注解,这样会有更好的可读性
## flow 类型注解 Type Annotations
flow可以帮我们推断出绝大多数的变量或类型,类型注解可以用了函数的参数,变量的类型以及函数返回的类型

```
/**
 * 类型注解
 * @flow
*/
function cf(n,m){
    return n*m
}
cf('100','100')
let num:number = 123;
// num = 'sss';//会报错
function next():number {
    // return 100;
    return 'cc';//报出语法错误
}
//需要注意的是如果没有返回值,默认返回undefined,也会 报错
function pre(): void{
    没有返回值就标记void
}
```
## 原始类型
支持6种原始类型数据

```
/**
 * 原始数据类型
 * @flow
*/
const a:string = 'string'
const b:number = Infinity//NaN//100
const c:boolean = true //false
const d:null = null
const e:void = undefined
const f:symbol = Symbol()

```
## 数组类型
有结构的类型限制

```
/**
 * 数组类型
 * @flow
*/
// 定义纯数据类型的数组
const arr:Array<number> = [1,2,3]
const arr2:number[] = [4,5,6]
// 元组,定义固定长度的数组
const arr3:[Number,string] = [10,'hh']
```
当一个函数当中同时返回多个返回值的时候可以使用元组类型
## 对象类型

```
/**
 * 对象类型
 * @flow
*/
//限制变量是对象类型使用{}
// 设置固定的键和值的类型,对象就必须有这些成员
const obj1 : {boo:string,coo:number} = {boo:'cc',coo:123}
// ?表示这个成员可有可无
const obj2 :{boo?:string,coo:number} = {coo:123}
// 设置任意成员的键值对类型,设置成什么类型就必须是什么类型
const obj3:{[string]:string} = {}
// obj3.key1 = 123;//Cannot assign `123` to `obj3.key1` because  number [1] is incompatible with  string [2].
obj3.key1 = 'abc'
obj3.key2 = 'def'
```
## 函数类型
限制回调函数的参数和返回值,可以使用类似箭头函数的函数签名的限制

```
/**
 * 函数类型
 * @flow
*/
function foo(callback: (string,number)=>void){
    callback('str',100)
}
foo(function(str,num){
    // str==>string
    // num==>number
})
```
## 特殊类型

```
/**
 * 特殊类型
 * @flow
*/
//字面量类型:限制变量必须是某一个值,一般不会单独使用,会配合联合用法组合使用这个值
const a :'foo' = 'foo'
// 联合类型用法:又称或类型,值只能存放三种变量之一
const b: 'success' | 'warning' | 'danger' = 'success'
//也可以用联合类型定义变量的类型
const c: string | number = 100//'100'
//用type关键词给类型别名或者是单独生成一个类型
type stringOrNumber = string | number
const d:stringOrNumber = '122'
//maybe类型 有可能类型,用?表示
const e: ?number =  undefined//null//100
```
## flow Mixed和Any(任意类型)
Mixed类型是所有类型的联合类型,可以是任何一个值

```
/**
 * Mixed和Any类型
 * @flow
*/
function passMixed(pass:mixed){

}
passMixed('ss')
passMixed(123)
passMixed(true)
function passAny(pass:any){

}
passAny('aa')
passAny(123)
passAny(null)
```
在语法上any是弱类型,mixed是强类型,any主要是为了兼容老代码产生的

```
/**
 * Mixed和Any类型
 * @flow
*/
function passMixed(pass:mixed){
    if(typeof pass === 'string'){
        pass.substr(1)
    }
    if(typeof pass === 'number'){
        pass*pass
    }
   
   
}
passMixed('ss')
passMixed(123)
passMixed(true)
function passAny(pass:any){
    pass.substr(1)
    pass*pass
}
passAny('aa')
passAny(123)
passAny(null)
```
## flow小结
flow官方类型文档
![image](88A3A7D8A7EF4194918F06740C5B4869)
第三方类型手册
![image](350746BEE9E14B8A93697CD4B18F4951)
## flow运行环境api的支持

```
/**
 * 运行环境api
 * @flow
*/
const obj:HTMLElement | null = document.getElementById('div')
```

api对应声明文件的链接
![image](D045D2F7AC39491BAA24F43AB406441B)


## TypeScript (JavaScript的超集)
### TypeScript的概述
TypeScript是JavaScript的超集,所谓超集就是在JavaScript原有的基础之上多了一些特性,包括类型系统和ES6+的支持,写完代码后编译成JavaScript
![image](8B9EB65EEE5548B589B75B76E1BC42E5)
TypeScript最低能编译ES3版本的JavaScript,兼容性良好,任何一种JavaScript运行环境都支持,如浏览器应用,node应用,react-native,electron等等

TypeScript相比JavaScript功能更强大,生态更健全、更完善，特别是开发工具这块，微软对开发工具的支持都特别友好，angular和vue3.0都是用JavaScript开发的，适合长期维持的大型项目
### TypeScript的缺点
1. 语言本身多了很多概念，如接口、泛型、枚举等等，会提高我们的学习成本，好在TypeScript是渐进式的，什么是渐进式？就是即便我们什么都不知道也可以按照JavaScript的语言去编写代码，我们完全可以学一个新特性使用一个新特性
2. 项目初期，TypeScript会增加一些项目成本，如类型声明需要单独编写
## TypeScript的基本使用（快速上手）
TypeScript本身是node模块，可以安装到全局，但考虑到项目依赖的问题还是把它安装到项目当中更加合理
1. 初始化package.json
```
yarn init --yes
```
2.按照typescript模块依赖

```
yarn add typescript --dev
```
安装成功后可以在/node_modules/bin/中找到tsc命令,作用是编译typescript代码
3. 创建01-getting-started.ts文件

```
const hello = (name:string)=>{
    console.log(`hello ${name}`)
}
hello(`hcb`)
```
4. 运行编译命令,在编译过程中首先会检查代码中类型使用的异常,然后会移除掉类型注解之类的扩展语法,并且在这一过程中会自动去转换ECMAscript的新特性
```
yarn tsc 01-getting-started.ts
```
生成一个01-getting-started.js文件,里面是ES3的代码

```
var hello = function (name) {
    console.log("hello " + name);
};
hello("hcb");


```
> 即便类型注解报错,tsc命令也能编译出一个js文件,
同时就印证了即便使用typescript的最新系统,我们也可以使用最新的js语法标准

## 配置文件
tsc命令不仅可以编译某个指定的文件,也可以编译整个项目,需要创建一个typescript的配置文件
1. 在命令行生成配置文件

```
yarn tsc --init
```
生成tsconfig.json

```
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Basic Options */
    // "incremental": true,                   /* Enable incremental compilation */
    "target": "es2015", //所有标准都会转换成es5代码                   /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */
    "module": "commonjs",                     /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */
    // "lib": [],                             /* Specify library files to be included in the compilation. */
    // "allowJs": true,                       /* Allow javascript files to be compiled. */
    // "checkJs": true,                       /* Report errors in .js files. */
    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    // "declaration": true,                   /* Generates corresponding '.d.ts' file. */
    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */
    "sourceMap": true,   //开启源代码映射,这样在调试的时候就能使用sourceMap调试源代码了                  /* Generates corresponding '.map' file. */
    // "outFile": "./",                       /* Concatenate and emit output to single file. */
    "outDir": "dist",    //用于设置编译结果输出到的文件夹                    /* Redirect output structure to the directory. */
    "rootDir": "src",    //配置源代码也就是typescript代码所在的文件夹                   /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // "composite": true,                     /* Enable project compilation */
    // "tsBuildInfoFile": "./",               /* Specify file to store incremental compilation information */
    // "removeComments": true,                /* Do not emit comments to output. */
    // "noEmit": true,                        /* Do not emit outputs. */
    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */

    /* Strict Type-Checking Options *///以下类型检查配置
    "strict": true,        //开启严格模式 ,需要为每个成员指定明确的类型                  /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,              /* Enable strict null checks. */
    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */
    // "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */
    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */

    /* Additional Checks */
    // "noUnusedLocals": true,                /* Report errors on unused locals. */
    // "noUnusedParameters": true,            /* Report errors on unused parameters. */
    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */

    /* Module Resolution Options */
    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */
    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // "typeRoots": [],                       /* List of folders to include type definitions from. */
    // "types": [],                           /* Type declaration files to be included in compilation. */
    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    "esModuleInterop": true,                  /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */
    // "allowUmdGlobalAccess": true,          /* Allow accessing UMD globals from modules. */

    /* Source Map Options */
    // "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */

    /* Experimental Options */
    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */
    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */

    /* Advanced Options */
    "skipLibCheck": true,                     /* Skip type checking of declaration files. */
    "forceConsistentCasingInFileNames": true  /* Disallow inconsistently-cased references to the same file. */
  }
}

```
2. 创建src文件夹,把ts文件移入
3. 对这个项目 执行ts命令

```
yarn ts
```
生成的文件时es2015标准的js文件同时还生成了sourceMap文件

![image](F4B1A4907F2C459EB5DED9B341F651B5)
![image](4E6F7BA546B44B5BA8B8F4B17D3DA83F)

 ## 原始类型
 
```
/**
 * 原始数据类型
*/
// 非严格模式下string number boolean都允许为空为null,严格模式下是不 允许的
//在tsconfig中我们可以设置"strictNullChecks": true,启用严格的空检查。  
const a:string = 'hcb'
const b:number = 100
const c:boolean =  true
//void在非严格模式下能够为undefined或null,在严格模式下只能为undefined
const d:void = null // undefined//null在严格模式下会报错
const e: null = null
const f:undefined = undefined
const syb:symbol = Symbol();//这里用Symbol会报错这是为啥呢?
```
## 标准库声明
symbol会报错这是为啥呢?在tsconfig我们的target引用的es5标准库,es5的标准库没有Symbol这样一个内置类型
### 有两种解决办法
1. 修改tsconfig中的target为es2015,使用的是es2015标准库
2. 
```
"target": "es2015", 
```

2. 如果我们需要编译成es5,可以使用tsconfig的lib选项指定标准库,由于console对象是在浏览器中BOM对象提供的,ts把BOM和DOM归结到一个标准库文件上,所以我们就可以写一个DOM标准库就行了
```
"lib": ["es2015","DOM"],  
```
> 所谓标准库实际上就是内置对象所对应的声明文件,在代码当中使用这个对象就必须引用这个标准库,否则typescript就找不到所对应的类型,就会报错

## TypeScript 中文错误消息
typescript本身是支持多语言化的错误消息的,默认会根据你的开发系统和语言的设置选择一个错误消息语言,如果想要强制显示中文的错误消息可以执行以下命令

```
yarn tsc --locale zh-CN
```
这样绝大错误都是中文消息

![image](1C3539C7E7B546BDB09930F199DE0D5E)
![image](22DDEA644C7E4A3ABB9AF0679C8F9C00)


---

小知识:对于vscode的消息可以在配置选项中配置在vscode--file--preference--setting搜索typescript locale勾掉对勾可以关闭js的语法检查,但是我们不建议这样做,中文错误消息在Google很难搜索到相关消息,尽量使用英文的方式

---
## 作用域问题
在学习typescript当中,肯定要尝试不同的特性,这种情况下我们可能会遇到不同文件当中会有相同变量名称的情况,如下:

```
//01.ts
const a:string = 'hhh' 
```

```
//02.ts
const a:string = 'hcb' 
```
两个同名的变量都是全局变量这样就会报错:Cannot redeclare block-scoped variable 'a'.ts(2451)

解决这样问题的办法就是把相同名称的变量装在不同的作用域当中,例如:

```
//作用域问题
(function(){
    const a:string = 'hh'
})()
```
或者使用export 作为模块导出一下,模块是有模块作用域的

```
const a:string = 'hh'
export {}
//这里的{}只是一个语法并不是空对象
```
这样的话,模块当中的所有成员就变成了局部成员了,也就不会再出现冲突的问题了

## Object类型
TypeScript中的对象类型并不单指普通的对象类型,而是泛指所有的非原始类型,也就是对象、数组、函数

```
//Object类型
export {}
// typescript中的对象类型不单指普通对象,更包括数组和函数
const foo:object = function(){}//[]//{}
// 需要普通对象类型,要用对象字面量语法去声明
const obj: {foo:string,bar:number} = {foo:'hcb',bar:123}
```
更专业的方式是接口,后面会介绍
## 数组类型
和flow十分类似

```
// 数组类型
// 自变量声明时限制数组类型
const arr1:Array<number> = [1,2,3];
const arr2:number[] = [123,456,789];
// --------------------------------
// 在函数参数限制数组类型
function sum(...arg:number[]){
    return arg.reduce((prev,current)=>prev*current)
}
//参数定义为数值类型的数组,不能出现别的类型的值,如果出现字符串类型语法上就会报错
sum(1,2,3,'ffc');//报错:Argument of type '"ffc"' is not assignable to parameter of type 'number'.
```

## 元组类型
其实元组就是明确元素数量和元素类型的数组,下面使用数组字面量定义元组类型

```
//元组类型   Tuple
export {}
//对应类型不相符或者数量超出长度限制都会报错
const tuple:[number,string] = [12,'boo'];
// const tuple:[number,string] = [12,11];//报错
// const tuple:[number,string] = [12,'cc',11]//报错
// 通过数组解构的方式提取每个元素
const [age,number] = tuple;
//---------------------------------------------------------
//元组类型越来越常见
Object.entries({
    foo:123,
    bar:555
})//=>返回可枚举的键值对数组
//因为Object.entries是es2017出现的,需要在tsconfig的lib添加值"ES2017"

```
## 枚举类型
我们在应用开发中经常需要用某几个数值代表某种状态,如果在代码中直接使用012代表自变量状态的话,时间久了我们可能搞不清楚对应的数字是什么状态,而且时间长了还会混进了一些其他的值,去使用012以外的数字,这种情况使用枚举类型的值是最合适的了

```
//枚举(Enum)
export {}
const post = {
    title:'hello TypeScript',
    content:'ts是js的超集',
    status:0,//状态:0草稿1未发布2发布//如果在代码中直接使用012代表自变量状态的话,时间久了我们可能搞不清楚对应的数字是什么状态,而且时间长了还会混进了一些其他的值,去使用012以外的数字
}
```

因为枚举类型有两个特点
1. 能够给一组数值取上一个更好的名字
2. 一个枚举中只会存在几个固定的值,不会出现超出范围的可能性

### 枚举类型的基本使用

```
//枚举(Enum)
export {}
// 传统的JavaScript使用对象去模拟实现枚举
const PostStatus = {
    Draft:0,
    UnPubilshed:1,
    Published:2
}
// 然后我们就可以在代码当中使用这些对象的属性表示状态,
//这样就不会出现遗忘数字值代表什么的问题
const post = {
    title:'hello TypeScript',
    content:'ts是js的超集',
    status:PostStatus.Draft,//状态:0草稿1未发布2发布//如果在代码中直接使用012代表自变量状态的话,时间久了我们可能搞不清楚对应的数字是什么状态,而且时间长了还会混进了一些其他的值,去使用012以外的数字
}
//-------------------------------------
//现代的TypeScript当中有一个专门的枚举类型可以使用enum关键词声明枚举
// enum PostStatus2 {
//     Draft = 0,//需要注意的是这里使用的是等号而不是冒号
//     UnPubilshed = 1,
//     Published = 2
// }
// 需要注意的,在值为number时,是不用等号赋值的时候默认初始值是0,后面的属性在不设值的情况下是上一个属性值+1递增,如下
// enum PostStatus2 {
//     Draft = 6,//6//0
//     UnPubilshed,//7//1
//     Published//8//2

// }
// 枚举的值除了是数字外还可以是字符串,如果是字符串枚举的话,那我们需要手动的给每个枚举一个初始化的值
enum PostStatus2 {
    Draft = 'aaa',
    UnPubilshed ='bbb',
    Published = 'ccc'

}
const post2 = {
    title:'hello TypeScript',
    content:'ts是js的超集',
    status:PostStatus2.Draft,//使用枚举和使用对象的方式是一样的
}
```


> 需要注意的是枚举类型会入侵到我们运行时的代码,通俗的将就是会影响我们编译后的结果,我们在typescript使用的大部分类型经过编译转换过后都会被移除,因为他只是帮助我们在编译过程中做类型检查,而枚举不是,他最终会编译成一个双向的键值对对象,下面执行编译命令


```
yarn tsc
```
> 执行后的代码:

```
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// 传统的JavaScript使用对象去模拟实现枚举
var PostStatus = {
    Draft: 0,
    UnPubilshed: 1,
    Published: 2
};
// 然后我们就可以在代码当中使用这些对象的属性表示状态,
//这样就不会出现遗忘数字值代表什么的问题
var post = {
    title: 'hello TypeScript',
    content: 'ts是js的超集',
    status: PostStatus.Draft,
};
//-------------------------------------
//现代的TypeScript当中有一个专门的枚举类型可以使用enum关键词声明枚举
// enum PostStatus2 {
//     Draft = 0,//需要注意的是这里使用的是等号而不是冒号
//     UnPubilshed = 1,
//     Published = 2
// }
// 需要注意的,在值为number时,是不用等号赋值的时候默认初始值是0,后面的属性在不设值的情况下是上一个属性值+1递增,如下
// enum PostStatus2 {
//     Draft = 6,//6//0
//     UnPubilshed,//7//1
//     Published//8//2
// }
// 枚举的值除了是数字外还可以是字符串,如果是字符串枚举的话,那我们需要手动的给每个枚举一个初始化的值
var PostStatus2;
//这是一个双向的键值对对象,键中有值,值中有键
(function (PostStatus2) {
    PostStatus2["Draft"] = "aaa";
    PostStatus2["UnPubilshed"] = "bbb";
    PostStatus2["Published"] = "ccc";
})(PostStatus2 || (PostStatus2 = {}));
var post2 = {
    title: 'hello TypeScript',
    content: 'ts是js的超集',
    status: PostStatus2.Draft,
};
//# sourceMappingURL=07-enum-types.js.map
```
> 所谓双向键值对就是可以通过键获取值也可以通过值获取键,这样做的目的是让我们动态的根据枚举的值如012这样的值获取枚举的名称

```
enum PostStatus2 {
    Draft = 0,//需要注意的是这里使用的是等号而不是冒号
    UnPubilshed = 1,
    Published = 2
}
PostStatus2[0];//通过索引器的方式根据枚举的值动态获取枚举的名称
```
> 常量枚举

```
// 常量枚举,在enum前声明const
const enum PostStatus2 {
    Draft ,
    UnPubilshed ,
    Published 
}
const post2 = {
    title:'hello TypeScript',
    content:'ts是js的超集',
    status:PostStatus2.Draft,//使用枚举和使用对象的方式是一样的
}
```
```
yarn tsc
```
> 执行后的js代码:

```
var post2 = {
    title: 'hello TypeScript',
    content: 'ts是js的超集',
    status: 0 /* Draft */,
};
```
这里我们会看到枚举会被移除掉,使用枚举值的地方都会被替换成原来的具体数值,枚举的名称会在后面以注释的方式标注

以上就是在typescript中枚举类型的主要特征
## 函数类型
函数的类型约束主要是对函数的输入输出进行类型限制,输入是指参数,输出指返回值,不过呢在JavaScript有两种函数定义的方式,分别是==函数声明==和==函数表达式==,我们需要了解下在这两种方式如何进行类型约束
### 函数声明

```
// 函数声明
// 函数的参数类型和参数个数都是指定的,不能改变
//如果想某个参数是可选的就在参数名后加问号
function funcl (a:number,b?:number):string {
    return 'funcl'
}

funcl(100,200)
funcl(100)//语法错误参数个数少一个

// funcl(100,200,300)//语法错误参数个数多一个
// 或者使用es6添加默认值的特性来解决参数个数的问题
function funcl2 (a:number,b:number = 123):string {
    return 'funcl'
}
// 注意不管是可选参数还是默认参数都必须放在参数队列的最后位置
funcl2(111)
// 如果需要接收任意个数的参数,那么使用es6的rest操作符
function funcl3 (a:number,b:number = 123,...rest:number[]):string {
    return 'funcl'
}
// 以上就是函数类型声明的一个对应的限制
```
### 函数表达式


```
// 函数表达式
// 在把函数作为参数传递那种回调函数的形式,
// 对于回调函数我们必须约束回调函数的参数类型和返回值
// 这种情况我们就可以使用类似箭头函数的形式来去表示函数
const func2:(a:number,b:number)=>string = function(a:number,b:number):string {
    return 'func2'
}
```
这种方式我们在以后定义接口的时候会经常用到
## 任意类型
any类型是不安全的,弱类型,语法上不会报错,不建议用,主要用于兼容老的代码

```
// 任意类型---any类型
export {}
function stringify(value:any):any{
    return JSON.stringify(value)
}
stringify(100)
stringify('ccc')
stringify(true)
let hello: any = 'string';

hello = 123
hello = false
hello = undefined
```
## 隐式类型推断
在typescript当中,如果我们明确没有通过类型注解去标记变量类型,那typescript会根据变量的使用情况去推断变量的类型, 这样一种特性叫做隐式类型推断.

```
//隐式类型推断
export {}
let age = 18
age = "string";
//出现类型错误,因为这个时候age已经被推断成了number类型
//这种用法实际上相当于给age变量添加了number注解
// ---------------------------------
// 如果typescript无法推断变量的类型注解，就会给变量添加any类型注解
let foo//声明变量是并没有值就是any类型,也就是动态类型,这样的变量赋予任何值都不会报错,这就是隐式推断
foo = 100
foo = 'string'
//建议为每个变量添加明确的类型,便于以后更直观的了解代码
```
## 类型断言
在有些特殊的情况下,typescript无法推断出变量的具体类型,我们开发者可以根据代码的情况可以知道是什么变量类型的

```
/类型断言
export {}
//假定这个num,来自一个,明确的接口
const nums = [100,110,120,119,112]
const res = nums.find(i => i>0);
/**我们一目了然的知道那个数大于零,知道数组值得类型,
 * 但是typescript不知道,
 * 它只知道这个地方的返回值是const res: number | undefined,
 * 有可能找不到,此时我们就不能把这个值当成一个数字去使用,
 * 这种情况下我们就可以去断言这个数字是number类型的,
 * 断言的 意思是明确告诉typescript,
 * 相信我,这个值明确是number类型的
 * */

// const square = res*res
// 断言的两种方式
// 1.使用as关键词,此时我们的编辑器就能明确知道它是一个数字了
const nums1 = res as number
// 2.在变量的前面使用<>去断言,但是由于与jsx的标签有冲突不建议使用
const nums2 = <number>res
```
需要注意的是,类型断言不是类型转换,类型断言是代码编辑时用来明确代码类型的,不是代码运行时的类型转换,并且编译后类型断言也会消失
## 接口 interfaces
接口也是一种规范,更是一种契约,是一种抽象的概念,可以约定对象的结构,我们使用一个接口就必须遵循这个接口全部的约定

在typescript当中,接口最直观的体现就是用来约定一个对象当中具体应该有哪些成员,而且这些成员的类型又是什么样的
> 接口的基本作用

```
// 接口
export {}
//  2.定义接口
interface Post {
    title:string//键值对的结尾可以用逗号/分号或者省略
    content:string
}
/**
 * 3.在函数中可以给post对象的类型设置Post接口,
 * 此时就是显示的要求我们的对象必须有title和content这两个成员了
*/
function printPost (post:Post){
   /**
     * 1.这是对于post所接收的对象就有一定的要求,
     * 我们传入的对象必须存在一个title属性和一个content属性,
     * 只不过这种要求是隐形的,它没有明确的表达出来
     * 那这种情况下,我们就可以使用接口表现出这种约束
    */
    console.log(post.title)
    console.log(post.content)
}
printPost({
    title:'hello hcb',
    content:'ts是js的超集'
})
```

---

总结:接口就是约束对象的结构,一个对象去实现接口,就必须拥有这个接口当中的所有成员,
typescript中的接口是只是为我们有结构的数据做类型约束的,在实际运行阶段这个接口并没有意义

---
## 接口补充(可选成员,只读成员,动态成员)
对于接口中约定的成员还有一些特殊的用法
1. 可选成员,如果某个对象的成员可有可无的话可以在接口使用可选成员的的特性,用?表示

```
interface Post {
    title:string//键值对的结尾可以用逗号/分号或者省略
    content:string,
    subtitle?:string
}
```

2. 只读成员,不允许外界去设置它,使用readonly关键词去修饰,添加完readonly,我们的对象在初始化之后就不能修改这个成员了,如果再次修改就会报错
```
interface Post {
    title:string//键值对的结尾可以用逗号/分号或者省略
    content:string,
    subtitle?:string,
    readonly summary:string
}
```
实例

```
// 接口补充(可选成员,只读成员)
export {}
//  2.定义接口
interface Post {
    title:string//键值对的结尾可以用逗号/分号或者省略
    content:string,
    subtitle?:string,
    readonly summary:string
}
/**
 * 3.在函数中可以给post对象的类型设置Post接口,
 * 此时就是显示的要求我们的对象必须有title和content这两个成员了
*/
function printPost (post:Post){
   /**
     * 1.这是对于post所接收的对象就有一定的要求,
     * 我们传入的对象必须存在一个title属性和一个content属性,
     * 只不过这种要求是隐形的,它没有明确的表达出来
     * 那这种情况下,我们就可以使用接口表现出这种约束
    */
    console.log(post.title)
    console.log(post.content)
}
const post:Post = {
    title:'hello hcb',
    content:'ts是js的超集',
    summary:'只读,不允许修改'
}
// post.summary = '我就改了';//报错
printPost(post)
```

3. 动态成员,一般用于具有动态成员的对象,例如缓存对象

```
// 动态成员用法
interface Cache {
    [key:string]:string
}
const cache:Cache = {}
cache.foo = 'foo'
cache.bae = 'bar'
```

## 类 Classes
1. 类的作用:描述一类具体事物的抽象特征,例如手机就是一个类型,手机的特征就是能够打电话发短信上网,在这个类型下面还有一些细分的子类,这种子类会满足父类的所有特征还会多出一些额外的特征,如智能手机,除了打电话发短信还能使用app
2. 类用来描述一类具体对象的抽象成员,在es6以前js是通过函数+原型模拟实现类,从es6开始js有了专门的class
3. 在typescript中的class除了拥有es6的class所有用法还有额外的用法,例如对类成员有特殊的访问修饰符,还有抽象类的概念

### typescript中类的基本使用

```
// 类class
export {}
class Preson {
    // 在typescript中我们需要在类的当中明确的声明类的属性
    // 不是直接在构造函数当中动态的去添加属性
    name:string //= 'who'//这个语法时es2017定义的
    age:number
    // 需要注意的是类的属性必须具备初始值,要么在类的中声明属性值赋值,要么在类的构造函数中赋值
    constructor(name:string,age:number){
        this.name = name;
        this.age = age;
    }
    sayHi(msg:string) :void{
        console.log(`I am ${this.name},${this.age}`)
    }
}
```
## 类的访问修饰符
类的访问修饰符的作用:可以控制类当中成员的访问级别
- public修饰符声明类的共有属性,在typescript中,类声明名的属性默认是公有属性,public关键词可以被省略

```
public name:string 
```

- private修饰符声明类的私有属性,只能在类的内部去访问

```
private age:number
```

- protected修饰符声明类的受保护属性,同样在类实例化后不能被直接访问,只允许在子类访问对应的成员

```
protected gender:boolean
```
- constructor构造函数式默认的修饰符是public,如果改成private变成私有的,类就不能实例化访问了,只能通过静态方法去访问类的实例化

```
export {}
class Person {
    //public修饰符声明类的共有属性,在typescript中,类声明的属性默认是公有属性,public关键词可以被省略
    public name:string 
    // private修饰符声明类的私有属性,只能在类的内部去访问
    private age:number
    // protected修饰符声明类的受保护属性,同样来类实例化后不能被直接访问,只允许在子类访问对应的成员
    protected gender:boolean
    constructor(name:string,age:number){
        this.name = name;
        this.age = age;
        this.gender = true
    }
    sayHi(msg:string) :void{
        console.log(`I am ${this.name},${this.msg}`)
        console.log(this.age)
    }
}
// 创建子类继承Person类
class Student extends Person {
    private constructor(name:string,age:number){
        super(name,age)
        console.log(this.gender);//Property 'age' is private and only accessible within class 'Person'.通过this直接访问父类中protected修饰过的属性
    }
    static create(name:string,age:number){
        return new Student(name,age);
    }
}
const hcb = new Person('hcb',25)
console.log(hcb.name)
// console.log(hcb.age);//语法报错Property 'age' is private and only accessible within class 'Person'.age是私有属性不能直接访问
// console.log(hcb.gender);//Property 'age' is private and only accessible within class 'Person'.
// const gl = new Student('gl',7);//Constructor of class 'Student' is private and only accessible within the class declaration.
const gl = Student.create('gl',7)
```

- constructor构造函数如果被标记protected修饰符,这个类也是不能被实例化的,但是相比private是允许继承的
```
// 构造函数被标记为protected,这个类不允许被实例化,但是相比private,它允许被继承的
class Teacher extends Person {
    protected constructor(name:string,age:number){
        super(name,age)
        this.gender = false;
    }
}
// const mm = new Teacher('mm',18);//Constructor of class 'Teacher' is protected and only accessible within the class declaration.
class Woman extends Teacher {
    constructor(name:string,age:number){
        super(name,age);
    }
}
const wm = new Woman('luck',33)
```
## 类的只读属性(readonly)
readonly可以把属性设置 为只读属性,如果这个属性已经有了访问修饰符的话,readonly应该跟在访问修饰符的后面

```
// 类的只读属性
export {}
class Person {
    public name:string
    private age:number
    protected readonly gender:boolean
    constructor(name:string,age:number){
        this.name = name
        this.age = age
        this.gender = true
    }
    sayHi(msg:string):void{
        console.log(`I am ${this.name},${msg}`)
        console.log(this.age)
    }
}
const hcb = new Person('hcb',25)
console.log(hcb.name)
```
对于只读属性,我们可以在类型声明的时候直接通过等号的方式初始化,也可以在构造函数中初始化,两者只能选其一,初始化之后不允许被修改
## 类与接口
相比于类,接口的概念要更为抽象一点,我们可以接着之前手机的例子作比较,手机是一个类型,类型的实例都是能够打电话发短信的,因为手机这个类的特征就是打电话发短信,但是呢,我们能够打电话的不仅仅只有手机,那在以前呢还有比较常见的座机也能打电话,但是座机并不属于手机的类目,而是一个单独的类目因为它不能够发短信,也不能拿着到处跑,那在这种情况下也会出现不同的类与类之间也会出现一些共同的特征,那对于这些公共的特征我们会使用接口去抽象,那你可以理解为手机也能打电话,因为它实现了打电话的协议,而座机也能够打电话,因为它也实现了这个相同的协议,那这里的协议呢,我们在程序当中叫接口,当然如果你是第一次接触这种概念的话,可能理解起来有些吃力,那我个人的经验的就是多思考,多从生活的角度去想,那如果实在想不通的话,那就多用,在用的过程中慢慢的总结规律,时间长了自然也就好了

下面这两个类有相同的特性,如吃东西,会跑,这种 情况下就属于不同的类型实现了相同的接口,那可能有人会问我们为什么不给他们之间去抽象一个公共的父类,然后把公共的方法都定义到父类当中,原因是人和动物都会吃都会跑,但是人和动物吃东西是不一样的,他们只是都得有这个能力,而这个能力的实现是不一样的,那在这种情况下,我们就可以使用接口去约束这样的公共能力

```
// 类与接口
export {}
// 下面这两个例子有共同的特性
class Person {
    eat(food:string):void{
        console.log(`优雅的进餐:${food}`)
    }
    run(distance:number):void{
        console.log(`直立行走:${distance}`)
    }
}

class Animal {
    eat(food:string):void{
        console.log(`呼噜呼噜的吃:${food}`)
    }
    run(distance:number):void{
        console.log(`爬行:${distance}`)
    }
}
```
下面使用接口去约束这两个类公共的能力

```
// 类与接口
export {}
// 定义接口,添加成员约束,使用函数签名的方式约束方法的类型,而不做具体的方法实现
interface EatAndRun{
    eat(food:string):void
    run(distance:number):void
}
// 下面这两个例子有共同的特性
// 使用implements实现接口,此时在类型中必须要有对应的成员,
//没有就会报错,因为实现了这个接口就必须要有对用的成员 
class Person implements EatAndRun{
    eat(food:string):void{
        console.log(`优雅的进餐:${food}`)
    }
    run(distance:number):void{
        console.log(`直立行走:${distance}`)
    }
}

class Animal  implements EatAndRun{
    eat(food:string):void{
        console.log(`呼噜呼噜的吃:${food}`)
    }
    run(distance:number):void{
        console.log(`爬行:${distance}`)
    }
}
```
这里需要注意的是在java语言中,建议我们应该让每个接口的定义更加简单,更加细化,比如你的小摩托车会跑但不会吃,所以一个更合理的建议就是一个接口只去约束一个能力,然后让一个类型同时去实现多个接口,这样会更加合理一些

```
// 类与接口
export {}
// 定义接口,添加成员约束,使用函数签名的方式约束方法的类型,而不做具体的方法实现

interface Eat{
    eat(food:string):void
}
interface Run {
    run(distance:number):void
}
// 下面这两个例子有共同的特性
// 使用implements实现接口,此时在类型中必须要有对应的成员,
//没有就会报错,因为实现了这个接口就必须要有对用的成员 
class Person implements Eat,Run{
    eat(food:string):void{
        console.log(`优雅的进餐:${food}`)
    }
    run(distance:number):void{
        console.log(`直立行走:${distance}`)
    }
}

class Animal  implements Eat,Run{
    eat(food:string):void{
        console.log(`呼噜呼噜的吃:${food}`)
    }
    run(distance:number):void{
        console.log(`爬行:${distance}`)
    }
}
```
> 题外话:不要把自己约束在一门语言或者技术上面,最好是多接触多学习一些周边的语言或技术,因为这样的话会补充你的知识体系,简单的说,一个只了解JavaScript语言的程序员不可能设计出更高级的产品,例如wvvm最早出现在微软的wps当中,视野应该放宽,当你有更宽的知识面的时候你能够把多家的思想更好的融合在一起

## 抽象类
抽象类在某种程度上来说和接口有点类似,它也是可以约束子类当中必须有某一个成员,但是不同于接口的是,抽象类可以包含一些具体的实现,而接口只能是一个成员的抽象,它不包含具体的实现,一般比较大的类目我们都建议使用抽象类,例如我们刚刚所说的动物类,其实它就应该是抽象的,因为我们所说的动物它只是一个泛指,它并不够具体,那它的下面一定会有更细化的分离,比如说小狗小猫之类的,而且生活当中都会说买了一只狗或一只猫,不会说买了一只动物

定义抽象类就是在class前加一个关键词abstract,定义成抽象类过后就只能被继承,不能再用new的方式去创建实例化对象了,这种情况下必须使用子类去继承这个类型

```
// 抽象类(abstract)
export {}
// 定义抽象类
abstract class Animal{
    eat(food:string):void{
        console.log(`呼噜呼噜的吃:${food}`)
    }
    // 定义抽象类的抽象方法,需要注意的是抽象方法也不需要方法体
    // 当我们的父类有这样一个抽象方法时子类必须实现这个抽象方法
    abstract run(distance:number):void
}
// 可以使用vscode的代码修正功能自动的去生成实现
class Dog extends Animal {
    run(distance: number): void {
        console.log(`四只脚跑:${distance}`)
    }

}
// 此时我们实现的类就能同时拥有父类实现的方法以及自身实现的方法
const d = new Dog()
d.eat('宠粮')
d.run(200)
```

## 泛型
泛型就是指我们在定义接口或类的时候我们没有去指定类型,等到我们使用的时候再去指定具体类型的这样一个特征,简单的说,泛型就是指在函数声明时不去指定类型,等在调用时再去指定类型,这样做的目的是为了极大程度的复用我们的代码

```
//泛型
export {}
// 创建数值数组
function createNumberArray(length:number,value:number):number[]{
    const arr = Array<number>(length).fill(value)
    return arr;
}
// 创建字符串数组
function createStringArray(length:number,value:string):string[]{
    const arr = Array<string>(length).fill(value)
    return arr;
}
const numAry = createNumberArray(10,100)
const strAty = createStringArray(10,'voo')
// 以上这种情况,createNumberArray和createStringArray函数就会有冗余
//更合理的办法就是使用泛型,说白了就是把number和string这些变成 参数
//把类型变成参数,让我们在调用的时候去传递类型
function createArray<T>(length:number,value:T): T[] {
    const arr = Array<T>(length).fill(value)
    return arr;
}
const ary = createArray<string>(10,'aaa');

```

总的来说,泛型就是把我们定义时不能确定类型变成参数,让我们在使用时再去传递这样一个类型参数

## 类型声明
在实际的开发过程中我们难免会用到一些第三方的npm模块,而这些第三方模块并不是通过typescript编写的,如lodash,所以说它提供的成员不会有强类型的体验

```
// 类型声明
import { camelCase } from 'lodash'

// 使用declare语句进行类型声明,declare  +  函数签名
declare function camelCase (input:string): string
// 使用类型声明后再去访问这个函数就会有类型限制了

const res = camelCase('hello')


```
类型声明说白了就是一个成员在定义的时候由于种种原因没有进行类型声明,然后我们在使用它的时候再单独为它做出一个明确的声明,这种做法存在的原因就是为了兼容一下普通的js模块


由于typescript社区非常强大,目前绝多数的模块都已经提供了声明,我们只需要安装一些它所对应的类型模块就可以了,需要注意的是,类型声明模块只是一个开发依赖,里面不会提供任何集体的代码只是对一个模块做一些对应的声明

```
//lodash的类型声明模块
yarn add @types/lodash --dev
```
安装过后lodash模块就会有相应 的类型提示了

```
// 类型声明
import { camelCase } from 'lodash'//提示我们安装@types/lodash模块.Try `npm install @types/lodash` if it exists or add a new declaration (.d.ts) file containing `declare module 'lodash';`ts(7016)

// 使用declare语句进行类型声明,declare  +  函数签名
// declare function camelCase (input:string): string
// 使用类型声明后再去访问这个函数就会有类型限制了

const res = camelCase('hello')
// 类型声明说白了就是一个成员在定义的时候由于种种原因没有进行类型声明,
//然后我们在使用它的时候再单独为它做出一个明确的声明
//这种做法存在的原因就是为了兼容一下普通的js模块

```

![image](44F2C2369B9F46B9B63F4FEEBFAA26A7)

这些.d.ts文件都是typescript中专门做类型声明的文件

现在大部分模块内部都包含类型声明模块文件,不需要再单独安装类型声明模块了如query-string模块,如果没有类型声明模块,只能使用declare语句去单独声明

